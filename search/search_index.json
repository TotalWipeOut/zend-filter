{
    "docs": [
        {
            "location": "/",
            "text": "zend-filter\n\n\n\n\n\n\nThe \nZend\\Filter\n component provides a set of commonly needed data filters. It\nalso provides a simple filter chaining mechanism by which multiple filters may\nbe applied to a single datum in a user-defined order.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-filter/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-filter/",
            "title": "Home"
        },
        {
            "location": "/#zend-filter",
            "text": "The  Zend\\Filter  component provides a set of commonly needed data filters. It\nalso provides a simple filter chaining mechanism by which multiple filters may\nbe applied to a single datum in a user-defined order.   File issues at https://github.com/zendframework/zend-filter/issues  Documentation is at https://docs.zendframework.com/zend-filter/",
            "title": "zend-filter"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-filter provides a set of commonly needed data filters. It also provides a\nsimple filter chaining mechanism by which multiple filters may be applied to a\nsingle datum in a user-defined order.\n\n\nWhat is a filter?\n\n\nIn the physical world, a filter is typically used for removing unwanted portions\nof input, and the desired portion of the input passes through as filter output\n(e.g., coffee). In such scenarios, a filter is an operator that produces a\nsubset of the input. This type of filtering is useful for web applications:\nremoving illegal input, trimming unnecessary white space, etc.\n\n\nThis basic definition of a filter may be extended to include generalized\ntransformations upon input. A common transformation applied in web applications\nis the escaping of HTML entities. For example, if a form field is automatically\npopulated with untrusted input (e.g., from a web browser), this value should\neither be free of HTML entities or contain only escaped HTML entities, in order\nto prevent undesired behavior and security vulnerabilities. To meet this\nrequirement, HTML entities that appear in the input must either be removed or\nescaped. Of course, which approach is more appropriate depends on the situation.\nA filter that removes the HTML entities operates within the scope of the first\ndefinition of filter - an operator that produces a subset of the input. A filter\nthat escapes the HTML entities, however, transforms the input (e.g., \n&\n is\ntransformed to \n&amp;\n). Supporting such use cases for web developers is\nimportant, and \u201cto filter\u201d, in the context of using zend-filter, means to\nperform some transformations upon input data.\n\n\nBasic usage of filters\n\n\nHaving this filter definition established provides the foundation for\n\nZend\\Filter\\FilterInterface\n, which requires a single method named \nfilter()\n\nto be implemented by a filter class.\n\n\nFollowing is a basic example of using a filter upon two input data, the\nampersand (\n&\n) and double quote (\n\"\n) characters:\n\n\n$htmlEntities = new Zend\\Filter\\HtmlEntities();\n\necho $htmlEntities->filter('&'); // &amp;\necho $htmlEntities->filter('\"'); // &quot;\n\n\n\nAlso, if a filter inherits from \nZend\\Filter\\AbstractFilter\n (as do all of the\nout-of-the-box filters), you can also use them as invokables:\n\n\n$strtolower = new Zend\\Filter\\StringToLower;\n\necho $strtolower('I LOVE ZF2!'); // i love zf2!\n$zf2love = $strtolower('I LOVE ZF2!');\n\n\n\nUsing the StaticFilter\n\n\nIf it is inconvenient to load a given filter class and create an instance of the\nfilter, you can use \nStaticFilter\n with its \nexecute()\n method as an alternative\ninvocation style. The first argument of this method is a data input value, that\nyou would pass to the \nfilter()\n method. The second argument is a string, which\ncorresponds to the basename of the filter class, relative to the \nZend\\Filter\n\nnamespace. The \nexecute()\n method automatically loads the class, creates an\ninstance, and applies the \nfilter()\n method to the data input.\n\n\necho StaticFilter::execute('&', 'HtmlEntities');\n\n\n\nYou can also pass an array of constructor arguments, if they are needed for the\nfilter class:\n\n\necho StaticFilter::execute(\n    '\"',\n    'HtmlEntities',\n    ['quotestyle' => ENT_QUOTES]\n);\n\n\n\nThe static usage can be convenient for invoking a filter ad hoc, but if you have\nthe need to run a filter for multiple inputs, it\u2019s more efficient to follow the\nfirst example above, creating an instance of the filter object and calling its\n\nfilter()\n method.\n\n\nAlso, the \nFilterChain\n class allows you to instantiate and run multiple filter\nand validator classes on demand to process sets of input data. See the\n\nFilterChain\n chapter for more details.\n\n\nYou can set and receive the \nFilterPluginManager\n for the \nStaticFilter\n to\namend the standard filter classes.\n\n\n$pluginManager = StaticFilter::getPluginManager()->setInvokableClass(\n    'myNewFilter',\n    'MyCustom\\Filter\\MyNewFilter'\n);\n\nStaticFilter::setPluginManager(new MyFilterPluginManager());\n\n\n\nThis is useful when adding custom filters to be used by the \nStaticFilter\n.\n\n\nDouble filtering\n\n\nWhen using two filters in succession, you have to keep in mind that it is\noften not possible to get the original output by using the opposite filter. Take\nthe following example:\n\n\n$original = 'my_original_content';\n\n// Attach a filter\n$filter   = new Zend\\Filter\\Word\\UnderscoreToCamelCase();\n$filtered = $filter->filter($original);\n\n// Use it's opposite\n$filter2  = new Zend\\Filter\\Word\\CamelCaseToUnderscore();\n$filtered = $filter2->filter($filtered)\n\n\n\nThe above code example could lead to the impression that you will get the\noriginal output after the second filter has been applied. But thinking logically\nthis is not the case. After applying the first filter, \nmy_original_content\n will\nbe changed to \nMyOriginalContent\n. But after applying the second filter, the result\nis \nMy_Original_Content\n.\n\n\nAs you can see it is not always possible to get the original output by using a\nfilter which seems to be the opposite. It depends on the filter and also on the\ngiven input.\n\n\nProviding filters via modules\n\n\nIf you wish to indicate that your zend-mvc module provides filters, have your\n\nModule\n class implement \nZend\\Filter\\FilterProviderInterface\n, which defines\nthe method:\n\n\n/**\n * @return array\n */\npublic function getFilterConfig();\n\n\n\nThe method should return an array of configuration following the\n\nzend-servicemanager configuration format\n.\n\n\nIf you are not using zend-mvc, but are using a dependency injection container\n(e.g., if you are using Expressive), you can also provide filters using the\ntop-level \nfilters\n configuration key; the value of that key should be\nzend-servicemanager configuration, as linked above.\n\n\n(zend-mvc users may also provide configuration in the same way, and omit\nimplementation of the \nFilterProviderInterface\n.)",
            "title": "Introduction"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-filter provides a set of commonly needed data filters. It also provides a\nsimple filter chaining mechanism by which multiple filters may be applied to a\nsingle datum in a user-defined order.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#what-is-a-filter",
            "text": "In the physical world, a filter is typically used for removing unwanted portions\nof input, and the desired portion of the input passes through as filter output\n(e.g., coffee). In such scenarios, a filter is an operator that produces a\nsubset of the input. This type of filtering is useful for web applications:\nremoving illegal input, trimming unnecessary white space, etc.  This basic definition of a filter may be extended to include generalized\ntransformations upon input. A common transformation applied in web applications\nis the escaping of HTML entities. For example, if a form field is automatically\npopulated with untrusted input (e.g., from a web browser), this value should\neither be free of HTML entities or contain only escaped HTML entities, in order\nto prevent undesired behavior and security vulnerabilities. To meet this\nrequirement, HTML entities that appear in the input must either be removed or\nescaped. Of course, which approach is more appropriate depends on the situation.\nA filter that removes the HTML entities operates within the scope of the first\ndefinition of filter - an operator that produces a subset of the input. A filter\nthat escapes the HTML entities, however, transforms the input (e.g.,  &  is\ntransformed to  &amp; ). Supporting such use cases for web developers is\nimportant, and \u201cto filter\u201d, in the context of using zend-filter, means to\nperform some transformations upon input data.",
            "title": "What is a filter?"
        },
        {
            "location": "/intro/#basic-usage-of-filters",
            "text": "Having this filter definition established provides the foundation for Zend\\Filter\\FilterInterface , which requires a single method named  filter() \nto be implemented by a filter class.  Following is a basic example of using a filter upon two input data, the\nampersand ( & ) and double quote ( \" ) characters:  $htmlEntities = new Zend\\Filter\\HtmlEntities();\n\necho $htmlEntities->filter('&'); // &amp;\necho $htmlEntities->filter('\"'); // &quot;  Also, if a filter inherits from  Zend\\Filter\\AbstractFilter  (as do all of the\nout-of-the-box filters), you can also use them as invokables:  $strtolower = new Zend\\Filter\\StringToLower;\n\necho $strtolower('I LOVE ZF2!'); // i love zf2!\n$zf2love = $strtolower('I LOVE ZF2!');",
            "title": "Basic usage of filters"
        },
        {
            "location": "/intro/#using-the-staticfilter",
            "text": "If it is inconvenient to load a given filter class and create an instance of the\nfilter, you can use  StaticFilter  with its  execute()  method as an alternative\ninvocation style. The first argument of this method is a data input value, that\nyou would pass to the  filter()  method. The second argument is a string, which\ncorresponds to the basename of the filter class, relative to the  Zend\\Filter \nnamespace. The  execute()  method automatically loads the class, creates an\ninstance, and applies the  filter()  method to the data input.  echo StaticFilter::execute('&', 'HtmlEntities');  You can also pass an array of constructor arguments, if they are needed for the\nfilter class:  echo StaticFilter::execute(\n    '\"',\n    'HtmlEntities',\n    ['quotestyle' => ENT_QUOTES]\n);  The static usage can be convenient for invoking a filter ad hoc, but if you have\nthe need to run a filter for multiple inputs, it\u2019s more efficient to follow the\nfirst example above, creating an instance of the filter object and calling its filter()  method.  Also, the  FilterChain  class allows you to instantiate and run multiple filter\nand validator classes on demand to process sets of input data. See the FilterChain  chapter for more details.  You can set and receive the  FilterPluginManager  for the  StaticFilter  to\namend the standard filter classes.  $pluginManager = StaticFilter::getPluginManager()->setInvokableClass(\n    'myNewFilter',\n    'MyCustom\\Filter\\MyNewFilter'\n);\n\nStaticFilter::setPluginManager(new MyFilterPluginManager());  This is useful when adding custom filters to be used by the  StaticFilter .",
            "title": "Using the StaticFilter"
        },
        {
            "location": "/intro/#double-filtering",
            "text": "When using two filters in succession, you have to keep in mind that it is\noften not possible to get the original output by using the opposite filter. Take\nthe following example:  $original = 'my_original_content';\n\n// Attach a filter\n$filter   = new Zend\\Filter\\Word\\UnderscoreToCamelCase();\n$filtered = $filter->filter($original);\n\n// Use it's opposite\n$filter2  = new Zend\\Filter\\Word\\CamelCaseToUnderscore();\n$filtered = $filter2->filter($filtered)  The above code example could lead to the impression that you will get the\noriginal output after the second filter has been applied. But thinking logically\nthis is not the case. After applying the first filter,  my_original_content  will\nbe changed to  MyOriginalContent . But after applying the second filter, the result\nis  My_Original_Content .  As you can see it is not always possible to get the original output by using a\nfilter which seems to be the opposite. It depends on the filter and also on the\ngiven input.",
            "title": "Double filtering"
        },
        {
            "location": "/intro/#providing-filters-via-modules",
            "text": "If you wish to indicate that your zend-mvc module provides filters, have your Module  class implement  Zend\\Filter\\FilterProviderInterface , which defines\nthe method:  /**\n * @return array\n */\npublic function getFilterConfig();  The method should return an array of configuration following the zend-servicemanager configuration format .  If you are not using zend-mvc, but are using a dependency injection container\n(e.g., if you are using Expressive), you can also provide filters using the\ntop-level  filters  configuration key; the value of that key should be\nzend-servicemanager configuration, as linked above.  (zend-mvc users may also provide configuration in the same way, and omit\nimplementation of the  FilterProviderInterface .)",
            "title": "Providing filters via modules"
        },
        {
            "location": "/standard-filters/",
            "text": "Standard Filter Classes\n\n\nzend-filter comes with a standard set of filters, available for immediate use.\n\n\nAlnum\n\n\nThe \nAlnum\n filter can be used to return only alphabetic characters and digits\nin the unicode \"letter\" and \"number\" categories, respectively. All other\ncharacters are suppressed.\n\n\nThis filter is part of the zend-i18n package; you will need to include that\npackage in your application to use it.\n\n\nSupported Options\n\n\nThe following options are supported for \nAlnum\n:\n\n\nAlnum([ boolean $allowWhiteSpace [, string $locale ]])\n\n\n\n\n\n\n\n$allowWhiteSpace\n: If set to true, then whitespace characters are allowed.\n  Otherwise they are suppressed. Default is \nfalse\n (whitespace is not allowed).\n  Methods for getting/setting the \nallowWhiteSpace\n option are also available:\n  \ngetAllowWhiteSpace()\n and \nsetAllowWhiteSpace()\n.\n\n\n\n\n\n\n$locale\n: The locale string used in identifying the characters to filter\n  (locale name, e.g. \nen_US\n). If unset, it will use the default locale\n  (\nLocale::getDefault()\n). Methods for getting/setting the locale are also\n  available: \ngetLocale()\n and \nsetLocale()\n.\n\n\n\n\n\n\nBasic Usage\n\n\n// Default settings, deny whitespace\n$filter = new \\Zend\\I18n\\Filter\\Alnum();\necho $filter->filter('This is (my) content: 123');\n// Returns 'Thisismycontent123'\n\n// First param in constructor is $allowWhiteSpace\n$filter = new \\Zend\\I18n\\Filter\\Alnum(true);\necho $filter->filter('This is (my) content: 123');\n// Returns 'This is my content 123'\n\n\n\n\n\nSupported languages\n\n\nAlnum\n works on almost all languages, except: Chinese, Japanese and Korean.\nWithin these languages, the english alphabet is used instead of the characters\nfrom these languages. The language itself is detected using the \nLocale\n\nclass.\n\n\n\n\nAlpha\n\n\nThe \nAlpha\n filter can be used to return only alphabetic characters in the unicode \"letter\"\ncategory. All other characters are suppressed.\n\n\nThis filter is part of the zend-i18n package; you will need to include that\npackage in your application to use it.\n\n\nSupported Options\n\n\nThe following options are supported for \nAlpha\n:\n\n\nAlpha([ boolean $allowWhiteSpace [, string $locale ]])\n\n\n\n\n\n\n\n$allowWhiteSpace\n: If set to true then whitespace characters are allowed.\n  Otherwise they are suppressed. Default is \nfalse\n (whitespace is not allowed).\n  Methods for getting/setting the allowWhiteSpace option are also available:\n  \ngetAllowWhiteSpace()\n and \nsetAllowWhiteSpace()\n.\n\n\n\n\n\n\n$locale\n: The locale string used in identifying the characters to filter\n  (locale name, e.g. \nen_US\n). If unset, it will use the default locale\n  (\nLocale::getDefault()\n).  Methods for getting/setting the locale are also\n  available: \ngetLocale()\n and \nsetLocale()\n.\n\n\n\n\n\n\nBasic Usage\n\n\n// Default settings, deny whitespace\n$filter = new \\Zend\\I18n\\Filter\\Alpha();\necho $filter->filter('This is (my) content: 123');\n// Returns 'Thisismycontent'\n\n// Allow whitespace\n$filter = new \\Zend\\I18n\\Filter\\Alpha(true);\necho $filter->filter('This is (my) content: 123');\n// Returns 'This is my content '\n\n\n\n\n\nSupported languages\n\n\nAlpha\n works on almost all languages, except: Chinese, Japanese and Korean.\nWithin these languages, the english alphabet is used instead of the characters\nfrom these languages. The language itself is detected using the \nLocale\n\nclass.\n\n\n\n\nBaseName\n\n\nZend\\Filter\\BaseName\n allows you to filter a string which contains the path to\na file, and it will return the base name of this file.\n\n\nSupported Options\n\n\nThere are no additional options for \nZend\\Filter\\BaseName\n.\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\BaseName();\n\nprint $filter->filter('/vol/tmp/filename');\n\n\n\nThis will return 'filename'.\n\n\n$filter = new Zend\\Filter\\BaseName();\n\nprint $filter->filter('/vol/tmp/filename.txt');\n\n\n\nThis will return '\nfilename.txt\n'.\n\n\nBlacklist\n\n\nThis filter will return \nnull\n if the value being filtered is present in the filter's list of\nvalues. If the value is not present, it will return that value.\n\n\nFor the opposite functionality, see the \nWhitelist\n filter\n.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\Blacklist\n:\n\n\n\n\nstrict\n: Uses strict mode when comparing; passed to \nin_array()\n's third argument.\n\n\nlist\n: An array of forbidden values.\n\n\n\n\nBasic Usage\n\n\n$blacklist = new \\Zend\\Filter\\Blacklist([\n    'list' => ['forbidden-1', 'forbidden-2']\n]);\necho $blacklist->filter('forbidden-1'); // => null\necho $blacklist->filter('allowed');     // => 'allowed'\n\n\n\nBoolean\n\n\nThis filter changes a given input to be a \nBOOLEAN\n value. This is often useful when working with\ndatabases or when processing form values.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\Boolean\n:\n\n\n\n\ncasting\n: When this option is set to \nTRUE\n, then any given input will be\n  cast to boolean.  This option defaults to \nTRUE\n.\n\n\ntranslations\n: This option sets the translations which will be used to detect localized input.\n\n\ntype\n: The \ntype\n option sets the boolean type which should be used. Read\n  the following for details.\n\n\n\n\nDefault Behavior\n\n\nBy default, this filter works by casting the input to a \nBOOLEAN\n value; in other words, it operates\nin a similar fashion to calling \n(boolean) $value\n.\n\n\n$filter = new Zend\\Filter\\Boolean();\n$value  = '';\n$result = $filter->filter($value);\n// returns false\n\n\n\nThis means that without providing any configuration, \nZend\\Filter\\Boolean\n accepts all input types\nand returns a \nBOOLEAN\n just as you would get by type casting to \nBOOLEAN\n.\n\n\nChanging the Default Behavior\n\n\nSometimes, casting with \n(boolean)\n will not suffice. \nZend\\Filter\\Boolean\n\nallows you to configure specific types to convert, as well as which to omit.\n\n\nThe following types can be handled (in this precedence order):\n\n\n\n\nlocalized\n: Converts any string as mapped (case sensitive) in the \ntranslations\n option.\n\n\nfalse\n: Converts a string equal to the word \"false\" (case insensitive) to boolean \nFALSE\n.\n\n\nnull\n: Converts a \nNULL\n value to \nFALSE\n.\n\n\narray\n: Converts an empty \narray\n to \nFALSE\n.\n\n\nzero\n: Converts a string to \nFALSE\n if it equates to \n'0'\n after type juggling.\n\n\nstring\n: Converts an empty string \n''\n to \nFALSE\n.\n\n\nfloat\n: Converts a float \n0.0\n value to \nFALSE\n.\n\n\ninteger\n: Converts an integer \n0\n value to \nFALSE\n.\n\n\nboolean\n: Returns a boolean value as is.\n\n\n\n\nThere are 2 additional special types:\n\n\n\n\nall\n: Converts all above types to \nBOOLEAN\n. The same as setting all above types.\n\n\nphp\n: Converts all above types to \nBOOLEAN\n except \nlocalized\n or \nfalse\n. The same as setting all above types except \nlocalized\n or \nfalse\n.\n\n\n\n\nAll other given values will return \nTRUE\n by default.\n\n\nThere are several ways to select which of the above types are filtered. You can\ngive one or multiple types and add them, you can give an array, you can use\nconstants, or you can give a textual string.  See the following examples:\n\n\n// converts 0 to false\n$filter = new Zend\\Filter\\Boolean(Zend\\Filter\\Boolean::TYPE_INTEGER);\n\n// converts 0 and '0' to false\n$filter = new Zend\\Filter\\Boolean(\n    Zend\\Filter\\Boolean::TYPE_INTEGER + Zend\\Filter\\Boolean::TYPE_ZERO_STRING\n);\n\n// converts 0 and '0' to false\n$filter = new Zend\\Filter\\Boolean([\n    'type' => [\n        Zend\\Filter\\Boolean::TYPE_INTEGER,\n        Zend\\Filter\\Boolean::TYPE_ZERO_STRING,\n    ],\n]);\n\n// converts 0 and '0' to false\n$filter = new Zend\\Filter\\Boolean([\n    'type' => [\n        'integer',\n        'zero',\n    ],\n]);\n\n\n\nYou can also give an instance of \nZend\\Config\\Config\n to set the desired types.\nTo set types after instantiation, use the \nsetType()\n method.\n\n\nLocalized Booleans\n\n\nAs mentioned previously, \nZend\\Filter\\Boolean\n can also recognise localized \"yes\" and \"no\" strings.\nThis means that you can ask your customer in a form for \"yes\" or \"no\" within his native language and\n\nZend\\Filter\\Boolean\n will convert the response to the appropriate boolean value.\n\n\nTo set the translation and the corresponding value, you can use the \ntranslations\n option or the\nmethod \nsetTranslations\n. The translations must be set for any values you wish to map to boolean values.\n\n\n$filter = new Zend\\Filter\\Boolean([\n    'type'         => Zend\\Filter\\Boolean::TYPE_LOCALIZED,\n    'translations' => [\n        'ja'   => true,\n        'nein' => false,\n        'yes'  => true,\n        'no'   => false,\n    ],\n]);\n\n// returns false\n$result = $filter->filter('nein');\n\n// returns true\n$result = $filter->filter('yes');\n\n\n\nDisable Casting\n\n\nSometimes it is necessary to recognise only \nTRUE\n or \nFALSE\n and return all\nother values without changes. \nZend\\Filter\\Boolean\n allows you to do this by\nsetting the \ncasting\n option to \nFALSE\n.\n\n\nIn this case \nZend\\Filter\\Boolean\n will work as described in the following\ntable, which shows which values return \nTRUE\n or \nFALSE\n. All other given values\nare returned without change when \ncasting\n is set to \nFALSE\n\n\n\n\n\n\n\n\nType Constant\n\n\nType String\n\n\nTrue\n\n\nFalse\n\n\n\n\n\n\n\n\n\n\nZend\\Filter\\Boolean::TYPE_BOOLEAN\n\n\nboolean\n\n\nTRUE\n\n\nFALSE\n\n\n\n\n\n\nZend\\Filter\\Boolean::TYPE_EMPTY_ARRAY\n\n\narray\n\n\n\n\n[]\n\n\n\n\n\n\nZend\\Filter\\Boolean::TYPE_FALSE_STRING\n\n\nfalse\n\n\n'false'\n (case insensitive)\n\n\n'true'\n (case insensitive)\n\n\n\n\n\n\nZend\\Filter\\Boolean::TYPE_FLOAT\n\n\nfloat\n\n\n1.0\n\n\n0.0\n\n\n\n\n\n\nZend\\Filter\\Boolean::TYPE_INTEGER\n\n\ninteger\n\n\n1\n\n\n0\n\n\n\n\n\n\nZend\\Filter\\Boolean::TYPE_NULL\n\n\nnull\n\n\n\n\nNULL\n\n\n\n\n\n\nZend\\Filter\\Boolean::TYPE_STRING\n\n\nstring\n\n\n\n\n''\n\n\n\n\n\n\nZend\\Filter\\Boolean::TYPE_ZERO_STRING\n\n\nzero\n\n\n'1'\n\n\n'0'\n\n\n\n\n\n\n\n\nThe following example shows the behavior when changing the \ncasting\n option:\n\n\n$filter = new Zend\\Filter\\Boolean([\n    'type'    => Zend\\Filter\\Boolean::TYPE_ALL,\n    'casting' => false,\n]);\n\n// returns false\n$result = $filter->filter(0);\n\n// returns true\n$result = $filter->filter(1);\n\n// returns the value\n$result = $filter->filter(2);\n\n\n\nCallback\n\n\nThis filter allows you to use own methods in conjunction with \nZend\\Filter\n. You\ndon't have to create a new filter when you already have a method which does the\njob.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\Callback\n:\n\n\n\n\ncallback\n: This sets the callback which should be used.\n\n\ncallback_params\n: This property sets the options which are used when the\n  callback is processed.\n\n\n\n\nBasic Usage\n\n\nThe usage of this filter is quite simple. In this example, we want to create a\nfilter which reverses a string:\n\n\n$filter = new Zend\\Filter\\Callback('strrev');\n\nprint $filter->filter('Hello!');\n// returns \"!olleH\"\n\n\n\nAs you can see it's really simple to use a callback to define custom filters. It\nis also possible to use a method, which is defined within a class, by giving an\narray as the callback:\n\n\nclass MyClass\n{\n    public static function reverse($param);\n}\n\n// The filter definition\n$filter = new Zend\\Filter\\Callback(array('MyClass', 'reverse'));\nprint $filter->filter('Hello!');\n\n\n\nAs of PHP 5.5 you can use ::class resolution for given callback class:\n\n\nclass MyClass\n{\n    public function __invoke($param);\n}\n\n// The filter definition\n$filter = new Zend\\Filter\\Callback(MyClass::class);\nprint $filter->filter('Hello!');\n\n\n\nTo get the actual set callback use \ngetCallback()\n and to set another callback\nuse \nsetCallback()\n.\n\n\n\n\nPossible exceptions\n\n\nYou should note that defining a callback method which can not be called will\nraise an exception.\n\n\n\n\nDefault Parameters Within a Callback\n\n\nIt is also possible to define default parameters, which are given to the called\nmethod as an array when the filter is executed. This array will be concatenated\nwith the value which will be filtered.\n\n\n$filter = new Zend\\Filter\\Callback([\n    'callback' => 'MyMethod',\n    'options'  => ['key' => 'param1', 'key2' => 'param2']\n]);\n$filter->filter(['value' => 'Hello']);\n\n\n\nCalling the above method definition manually would look like this:\n\n\n$value = MyMethod('Hello', 'param1', 'param2');\n\n\n\nCompress and Decompress\n\n\nThese two filters are capable of compressing and decompressing strings, files, and directories.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\Compress\n and \nZend\\Filter\\Decompress\n:\n\n\n\n\nadapter\n: The compression adapter which should be used. It defaults to \nGz\n.\n\n\noptions\n: Additional options which are given to the adapter at initiation.\n  Each adapter supports its own options.\n\n\n\n\nSupported Compression Adapters\n\n\nThe following compression formats are supported by their own adapter:\n\n\n\n\nBz2\n\n\nGz\n\n\nLzf\n\n\nRar\n\n\nTar\n\n\nZip\n\n\n\n\nEach compression format has different capabilities as described below. All\ncompression filters may be used in approximately the same ways, and differ\nprimarily in the options available and the type of compression they offer (both\nalgorithmically as well as string vs. file vs. directory)\n\n\nGeneric Handling\n\n\nTo create a compression filter, you need to select the compression format you want to use. The\nfollowing example takes the \nBz2\n adapter. Details for all other adapters are described after\nthis section.\n\n\nThe two filters are basically identical, in that they utilize the same backends.\n\nZend\\Filter\\Compress\n should be used when you wish to compress items, and \nZend\\Filter\\Decompress\n\nshould be used when you wish to decompress items.\n\n\nFor instance, if we want to compress a string, we have to initialize \nZend\\Filter\\Compress\n and\nindicate the desired adapter:\n\n\n$filter = new Zend\\Filter\\Compress('Bz2');\n\n\n\nTo use a different adapter, you simply specify it to the constructor.\n\n\nYou may also provide an array of options or a \nTraversable\n object. If you do,\nprovide minimally the key \"adapter\", and then either the key \"options\" or\n\"adapterOptions\", both of which should be an array of options to provide to the\nadapter on instantiation.\n\n\n$filter = new Zend\\Filter\\Compress([\n    'adapter' => 'Bz2',\n    'options' => [\n        'blocksize' => 8,\n    ],\n]);\n\n\n\n\n\nDefault compression Adapter\n\n\nWhen no compression adapter is given, then the \nGz\n adapter will be used.\n\n\n\n\nDecompression is essentially the same usage; we simply use the \nDecompress\n\nfilter instead:\n\n\n$filter = new Zend\\Filter\\Decompress('Bz2');\n\n\n\nTo get the compressed string, we have to give the original string. The filtered value is the\ncompressed version of the original string.\n\n\n$filter     = new Zend\\Filter\\Compress('Bz2');\n$compressed = $filter->filter('Uncompressed string');\n// Returns the compressed string\n\n\n\nDecompression works in reverse, accepting the compressed string, and returning\nthe original:\n\n\n$filter     = new Zend\\Filter\\Decompress('Bz2');\n$compressed = $filter->filter('Compressed string');\n// Returns the original, uncompressed string\n\n\n\n\n\nNote on string compression\n\n\nNot all adapters support string compression. Compression formats like \nRar\n\ncan only handle files and directories. For details, consult the section for\nthe adapter you wish to use.\n\n\n\n\nCreating an Archive\n\n\nCreating an archive file works almost the same as compressing a string. However, in this case we\nneed an additional parameter which holds the name of the archive we want to create.\n\n\n$filter = new Zend\\Filter\\Compress([\n    'adapter' => 'Bz2',\n    'options' => [\n        'archive' => 'filename.bz2',\n    ],\n]);\n$compressed = $filter->filter('Uncompressed string');\n// Returns true on success, and creates the archive file\n\n\n\nIn the above example, the uncompressed string is compressed, and is then written\ninto the given archive file.\n\n\n\n\nExisting archives will be overwritten\n\n\nThe content of any existing file will be overwritten when the given filename\nof the archive already exists.\n\n\n\n\nWhen you want to compress a file, then you must give the name of the file with its path:\n\n\n$filter = new Zend\\Filter\\Compress([\n    'adapter' => 'Bz2',\n    'options' => [\n        'archive' => 'filename.bz2'\n    ],\n]);\n$compressed = $filter->filter('C:\\temp\\compressme.txt');\n// Returns true on success and creates the archive file\n\n\n\nYou may also specify a directory instead of a filename. In this case the whole\ndirectory with all its files and subdirectories will be compressed into the\narchive:\n\n\n$filter = new Zend\\Filter\\Compress([\n    'adapter' => 'Bz2',\n    'options' => [\n        'archive' => 'filename.bz2'\n    ],\n]);\n$compressed = $filter->filter('C:\\temp\\somedir');\n// Returns true on success and creates the archive file\n\n\n\n\n\nDo not compress large or base directories\n\n\nYou should never compress large or base directories like a complete partition.\nCompressing a complete partition is a very time consuming task which can lead\nto massive problems on your server when there is not enough space or your\nscript takes too much time.\n\n\n\n\nDecompressing an Archive\n\n\nDecompressing an archive file works almost like compressing it. You must specify either the\n\narchive\n parameter, or give the filename of the archive when you decompress the file.\n\n\n$filter = new Zend\\Filter\\Decompress('Bz2');\n$decompressed = $filter->filter('filename.bz2');\n// Returns true on success and decompresses the archive file\n\n\n\nSome adapters support decompressing the archive into another subdirectory. In\nthis case you can set the \ntarget\n parameter:\n\n\n$filter = new Zend\\Filter\\Decompress([\n    'adapter' => 'Zip',\n    'options' => [\n        'target' => 'C:\\temp',\n    ]\n]);\n$decompressed = $filter->filter('filename.zip');\n// Returns true on success, and decompresses the archive file\n// into the given target directory\n\n\n\n\n\nDirectories to extract to must exist\n\n\nWhen you want to decompress an archive into a directory, then the target\ndirectory must exist.\n\n\n\n\nBz2 Adapter\n\n\nThe Bz2 Adapter can compress and decompress:\n\n\n\n\nStrings\n\n\nFiles\n\n\nDirectories\n\n\n\n\nThis adapter makes use of PHP's Bz2 extension.\n\n\nTo customize compression, this adapter supports the following options:\n\n\n\n\narchive\n: This parameter sets the archive file which should be used or created.\n\n\nblocksize\n: This parameter sets the blocksize to use. It can be from '0' to\n  '9'. The default value is '4'.\n\n\n\n\nAll options can be set at instantiation or by using a related method; for example, the related\nmethods for 'blocksize' are \ngetBlocksize()\n and \nsetBlocksize()\n. You can also use the\n\nsetOptions()\n method, which accepts an array of all options.\n\n\nGz Adapter\n\n\nThe Gz Adapter can compress and decompress:\n\n\n\n\nStrings\n\n\nFiles\n\n\nDirectories\n\n\n\n\nThis adapter makes use of PHP's Zlib extension.\n\n\nTo customize the compression this adapter supports the following options:\n\n\n\n\narchive\n: This parameter sets the archive file which should be used or created.\n\n\nlevel\n: This compression level to use. It can be from '0' to '9'. The default\n  value is '9'.\n\n\nmode\n: There are two supported modes. \ncompress\n and \ndeflate\n. The default\n  value is \ncompress\n.\n\n\n\n\nAll options can be set at initiation or by using a related method. For example, the related methods\nfor \nlevel\n are \ngetLevel()\n and \nsetLevel()\n. You can also use the \nsetOptions()\n method which\naccepts an array of all options.\n\n\nLzf Adapter\n\n\nThe Lzf Adapter can compress and decompress:\n\n\n\n\nStrings\n\n\n\n\n\n\nLzf supports only strings\n\n\nThe Lzf adapter can not handle files and directories.\n\n\n\n\nThis adapter makes use of PHP's Lzf extension.\n\n\nThere are no options available to customize this adapter.\n\n\nRar Adapter\n\n\nThe Rar Adapter can compress and decompress:\n\n\n\n\nFiles\n\n\nDirectories\n\n\n\n\n\n\nRar does not support strings\n\n\nThe Rar Adapter can not handle strings.\n\n\n\n\nThis adapter makes use of PHP's Rar extension.\n\n\n\n\nRar compression not supported\n\n\nDue to restrictions with the Rar compression format, there is no compression\navailable for free. When you want to compress files into a new Rar archive,\nyou must provide a callback to the adapter that can invoke a Rar compression\nprogram.\n\n\n\n\nTo customize compression, this adapter supports the following options:\n\n\n\n\narchive\n: This parameter sets the archive file which should be used or created.\n\n\ncallback\n: A callback which provides compression support to this adapter.\n\n\npassword\n: The password which has to be used for decompression.\n\n\ntarget\n: The target where the decompressed files will be written to.\n\n\n\n\nAll options can be set at instantiation or by using a related method. For example, the related\nmethods for \ntarget\n are \ngetTarget()\n and \nsetTarget()\n. You can also use the \nsetOptions()\n method\nwhich accepts an array of all options.\n\n\nTar Adapter\n\n\nThe Tar Adapter can compress and decompress:\n\n\n\n\nFiles\n\n\nDirectories\n\n\n\n\n\n\nTar does not support strings\n\n\nThe Tar Adapter can not handle strings.\n\n\n\n\nThis adapter makes use of PEAR's \nArchive_Tar\n component.\n\n\nTo customize compression, this adapter supports the following options:\n\n\n\n\narchive\n: This parameter sets the archive file which should be used or created.\n\n\nmode\n: A mode to use for compression. Supported are either \nNULL\n, which\n  means no compression at all; \nGz\n, which makes use of PHP's Zlib extension;\n  and \nBz2\n, which makes use of PHP's Bz2 extension. The default value is \nNULL\n.\n\n\ntarget\n: The target where the decompressed files will be written to.\n\n\n\n\nAll options can be set at instantiation or by using a related method. For\nexample, the related methods for \ntarget\n are \ngetTarget()\n and \nsetTarget()\n.\nYou can also use the \nsetOptions()\n method which accepts an array of all\noptions.\n\n\n\n\nDirectory usage\n\n\nWhen compressing directories with Tar, the complete file path is used. This\nmeans that created Tar files will not only have the subdirectory, but the\ncomplete path for the compressed file.\n\n\n\n\nZip Adapter\n\n\nThe Zip Adapter can compress and decompress:\n\n\n\n\nStrings\n\n\nFiles\n\n\nDirectories\n\n\n\n\n\n\nZip does not support string decompression\n\n\nThe Zip Adapter can not handle decompression to a string; decompression will\nalways be written to a file.\n\n\n\n\nThis adapter makes use of PHP's \nZip\n extension.\n\n\nTo customize compression, this adapter supports the following options:\n\n\n\n\narchive\n: This parameter sets the archive file which should be used or created.\n\n\ntarget\n: The target where the decompressed files will be written to.\n\n\n\n\nAll options can be set at instantiation or by using a related method. For example, the related\nmethods for \ntarget\n are \ngetTarget()\n and \nsetTarget()\n. You can also use the \nsetOptions()\n method\nwhich accepts an array of all options.\n\n\nDigits\n\n\nReturns the string \n$value\n, removing all but digits.\n\n\nSupported Options\n\n\nThere are no additional options for \nZend\\Filter\\Digits\n.\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\Digits();\n\nprint $filter->filter('October 2012');\n\n\n\nThis returns \"2012\".\n\n\n$filter = new Zend\\Filter\\Digits();\n\nprint $filter->filter('HTML 5 for Dummies');\n\n\n\nThis returns \"5\".\n\n\nDir\n\n\nGiven a string containing a path to a file, this function will return the name of the directory.\n\n\nSupported Options\n\n\nThere are no additional options for \nZend\\Filter\\Dir\n.\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\Dir();\n\nprint $filter->filter('/etc/passwd');\n\n\n\nThis returns \n/etc\n.\n\n\n$filter = new Zend\\Filter\\Dir();\n\nprint $filter->filter('C:/Temp/x');\n\n\n\nThis returns \nC:/Temp\n.\n\n\nEncrypt and Decrypt\n\n\nThese filters allow encrypting and decrypting any given string; they do so via\nthe use of adapters. Included adapters support \nZend\\Crypt\\BlockCipher\n and\nPHP's OpenSSL extension.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\Encrypt\n and\n\nZend\\Filter\\Decrypt\n, and segregated by adapter.\n\n\nGeneral options\n\n\n\n\nadapter\n: This sets the encryption adapter to use.\n\n\ncompression\n: If the encrypted value should be compressed. Default is no\n  compression.\n\n\n\n\nBlockCipher options\n\n\n\n\nalgorithm\n: The algorithm to use with \nZend\\Crypt\\Symmetric\\Mcrypt\n (use the\n  the \ngetSupportedAlgorithms()\n method of that class to determine what is\n  supported). If not set, it defaults to \naes\n, the Advanced Encryption Standard\n  (see the \nzend-crypt BlockCipher documentation\n\n  for details).\n\n\nkey\n: The encryption key with which the input will be encrypted. You need the\n  same key for decryption.\n\n\nmode\n: The encryption mode to use. It should be a\n  \nvalid PHP mcrypt modes\n.\n  If not set, it defaults to 'cbc'.\n\n\nmode_directory\n: The directory where the mode can be found. If not set, it\n  defaults to the path set within the \nMcrypt\n extension.\n\n\nvector\n: The initialization vector which shall be used. If not set, it will\n  be a random vector.\n\n\n\n\nOpenSSL options\n\n\n\n\nenvelope\n: The encrypted envelope key from the user who encrypted the\n  content. You can either provide the path and filename of the key file, or just\n  the content of the key file itself. When the \npackage\n option has been set,\n  then you can omit this parameter.\n\n\npackage\n: If the envelope key should be packed with the encrypted value.\n  Default is \nFALSE\n.\n\n\nprivate\n: The private key to use for encrypting the content. You can either\n  provide the path and filename of the key file, or just the content of the key\n  file itself.\n\n\npublic\n: The public key of the user for whom you want to provide the\n  encrypted content. You can either provide the path and filename of the key\n  file, or just the content of the key file itself.\n\n\n\n\nAdapter Usage\n\n\nAs these two encryption methodologies work completely different, the usage\nof the adapters differ. You have to select the adapter you want to use when\ninitiating the filter.\n\n\n// Use the BlockCipher adapter\n$filter1 = new Zend\\Filter\\Encrypt(['adapter' => 'BlockCipher']);\n\n// Use the OpenSSL adapter\n$filter2 = new Zend\\Filter\\Encrypt(['adapter' => 'openssl']);\n\n\n\nTo set another adapter, you can use \nsetAdapter()\n; \ngetAdapter()\n will return\nthe currently composed adapter.\n\n\n// Use the OpenSSL adapter\n$filter = new Zend\\Filter\\Encrypt();\n$filter->setAdapter('openssl');\n\n\n\n\n\nDefault adapter\n\n\nWhen you do not supply the \nadapter\n option or do not call \nsetAdapter()\n, the\n\nBlockCipher\n adapter will be used per default.\n\n\n\n\nEncryption with BlockCipher\n\n\nTo encrypt a string using the \nBlockCipher\n adapter, you have to specify the\nencryption key by either calling the \nsetKey()\n method or passing it to the\nconstructor.\n\n\n// Use the default AES encryption algorithm\n$filter = new Zend\\Filter\\Encrypt(['adapter' => 'BlockCipher']);\n$filter->setKey('encryption key');\n\n// or\n// $filter = new Zend\\Filter\\Encrypt([\n//     'adapter' => 'BlockCipher',\n//     'key'     => 'encryption key'\n// ]);\n\n$encrypted = $filter->filter('text to be encrypted');\nprintf (\"Encrypted text: %s\\n\", $encrypted);\n\n\n\nYou can get and set the encryption values after construction using the\n\ngetEncryption()\n and \nsetEncryption()\n methods:\n\n\n// Use the default AES encryption algorithm\n$filter = new Zend\\Filter\\Encrypt(['adapter' => 'BlockCipher']);\n$filter->setKey('encryption key');\nvar_dump($filter->getEncryption());\n\n// Will print:\n//array(4) {\n//  [\"key_iteration\"]=>\n//  int(5000)\n//  [\"algorithm\"]=>\n//  string(3) \"aes\"\n//  [\"hash\"]=>\n//  string(6) \"sha256\"\n//  [\"key\"]=>\n//  string(14) \"encryption key\"\n//}\n\n\n\n\n\nDefault BlockCipher algorithm\n\n\nThe \nBlockCipher\n adapter uses the \nMcrypt\n extension\nby default. That means you will need to install the Mcrypt module in your PHP\nenvironment.\n\n\n\n\nIf you don't specify an initialization Vector (salt or iv), the \nBlockCipher\n will\ngenerate a random value during each encryption. If you try to execute the\nfollowing code, the output will always be different (note that even if the output\nis always different, you can still decrypt it using the same key).\n\n\n$key  = 'encryption key';\n$text = 'message to encrypt';\n\n// use the default adapter that is BlockCipher\n$filter = new \\Zend\\Filter\\Encrypt();\n$filter->setKey('encryption key');\nfor ($i = 0; $i < 10; $i++) {\n   printf(\"%d) %s\\n\", $i, $filter->filter($text));\n}\n\n\n\nIf you want to obtain the same output, you need to specify a fixed vector, using\nthe \nsetVector()\n method. This following example always produces the same\nencryption output:\n\n\n// use the default adapter that is BlockCipher\n$filter = new \\Zend\\Filter\\Encrypt();\n$filter->setKey('encryption key');\n$filter->setVector('12345678901234567890');\nprintf(\"%s\\n\", $filter->filter('message'));\n\n// output:\n//\n04636a6cb8276fad0787a2e187803b6557f77825d5ca6ed4392be702b9754bb3MTIzNDU2Nzg5MDEyMzQ1NgZ+zPwTGpV6gQqPKECinig=\n\n\n\n\n\nUse different vectors\n\n\nFor security purposes, it's always better to use a different vector on each\nencryption. We suggest using \nsetVector()\n only in exceptional circumstances.\n\n\n\n\nDecryption with BlockCipher\n\n\nFor decrypting content previously encrypted with \nBlockCipher\n, you need to use\nthe same options used for encryption.\n\n\nIf you used only the encryption key, you can just use it to decrypt the content.\nAs soon as you have provided all options, decryption works the same as\nencryption.\n\n\n$content = '04636a6cb8276fad0787a2e187803b6557f77825d5ca6ed4392be702b9754bb3MTIzNDU2Nzg5MDEyMzQ1NgZ+zPwTGpV6gQqPKECinig=';\n// use the default adapter (BlockCipher):\n$filter = new Zend\\Filter\\Decrypt();\n$filter->setKey('encryption key');\nprintf(\"Decrypt: %s\\n\", $filter->filter($content));\n\n// output:\n// Decrypt: message\n\n\n\nNote that even if we did not specify the same vector, the \nBlockCipher\n is able\nto decrypt the message because the vector is stored in the encryption string\nitself (note that the vector can be stored in plaintext; it is not a secret, and\nonly used to improve the randomness of the encryption algorithm).\n\n\nEncryption with OpenSSL\n\n\nIf you have installed the \nOpenSSL\n extension, you can also use the \nOpenSSL\n\nadapter. You can get or set the public key either during instantiation, or later\nvia the \nsetPublicKey()\n method. The private key can also be set after-the-fact\nvia the \nsetPrivateKey()\n method.\n\n\n// Use openssl and provide a private key\n$filter = new Zend\\Filter\\Encrypt([\n   'adapter' => 'openssl',\n   'private' => '/path/to/mykey/private.pem',\n]);\n\n// Add the private key separately:\n$filter->setPublicKey('/public/key/path/public.pem');\n\n\n\n\n\nValid keys are required\n\n\nThe \nOpenSSL\n adapter will not work with invalid or missing keys.\n\n\n\n\nWhen you want to decode content encoded with a passphrase, you will not only\nneed the public key, but also the passphrase:\n\n\n// Use openssl and provide a private key\n$filter = new Zend\\Filter\\Encrypt([\n   'adapter' => 'openssl',\n   'passphrase' => 'enter here the passphrase for the private key',\n   'private' => '/path/to/mykey/private.pem',\n   'public' => '/public/key/path/public.pem'\n]);\n\n\n\nWhen providing the encrypted content to the recipient, you will also need to\nensure they have the passphrase and the envelope keys so they may decrypt the\nmessage. You can get the envelope keys using the \ngetEnvelopeKey()\n method:\n\n\nA complete example for encrypting content with \nOpenSSL\n looks like the\nfollowing:\n\n\n// Use openssl and provide a private key\n$filter = new Zend\\Filter\\Encrypt([\n   'adapter' => 'openssl',\n   'passphrase' => 'enter here the passphrase for the private key',\n   'private' => '/path/to/mykey/private.pem',\n   'public' => '/public/key/path/public.pem'\n]);\n\n$encrypted = $filter->filter('text_to_be_encoded');\n$envelope  = $filter->getEnvelopeKey();\nprint $encrypted;\n\n// For decryption look at the Decrypt filter\n\n\n\nSimplified usage with OpenSSL\n\n\nAs noted in the previous section, you need to provide the envelope key to the\nrecipient in order for them to decrypt the message. This adds complexity,\nparticularly if you are encrypting multiple values.\n\n\nTo simplify usage, you can set the \npackage\n option to \nTRUE\n when creating your\n\nEncrypt\n instance (the default value is \nFALSE\n). This will return a value\ncontaining both the encrypted message \nand\n the envelope key:\n\n\n// Use openssl and provide a private key\n$filter = new Zend\\Filter\\Encrypt([\n   'adapter' => 'openssl',\n   'private' => '/path/to/mykey/private.pem',\n   'public'  => '/public/key/path/public.pem',\n   'package' => true,\n]);\n\n$encrypted = $filter->filter('text_to_be_encoded');\nprint $encrypted;\n\n// For decryption look at the Decrypt filter\n\n\n\nNow the returned value contains the encrypted value and the envelope. You don't\nneed to fetch the envelope key separately.\n\n\nHowever, there is one negative aspect to this: the encrypted value can now only\nbe decrypted by using \nZend\\Filter\\Encrypt\n.\n\n\nCompressing Content\n\n\nBased on the original value, the encrypted value can be a very large string. To\nreduce the value, \nZend\\Filter\\Encrypt\n allows the usage of compression.\n\n\nThe \ncompression\n option can either be set to the name of a compression adapter,\nor to an array which sets all required options for the compression adapter.\n\n\n// Use basic compression adapter\n$filter1 = new Zend\\Filter\\Encrypt([\n   'adapter'     => 'openssl',\n   'private'     => '/path/to/mykey/private.pem',\n   'public'      => '/public/key/path/public.pem',\n   'package'     => true,\n   'compression' => 'bz2'\n]);\n\n// Compression adatper with options:\n$filter2 = new Zend\\Filter\\Encrypt([\n   'adapter'     => 'openssl',\n   'private'     => '/path/to/mykey/private.pem',\n   'public'      => '/public/key/path/public.pem',\n   'package'     => true,\n   'compression' => ['adapter' => 'zip', 'target' => '\\usr\\tmp\\tmp.zip']\n]);\n\n\n\n\n\nDecrypt using the same settings\n\n\nWhen you want to decrypt a value which is additionally compressed, then you\nneed to set the same compression settings for decryption as for encryption;\notherwise decryption will fail.\n\n\n\n\nDecryption with OpenSSL\n\n\nDecryption with \nOpenSSL\n follows the same patterns as for encryption, with one\ndifference: you must have all data, including the envelope key, from the person\nwho encrypted the content.\n\n\nAs an example:\n\n\n// Use openssl and provide a private key\n$filter = new Zend\\Filter\\Decrypt([\n   'adapter' => 'openssl',\n   'private' => '/path/to/mykey/private.pem'\n]);\n\n// Add the envelope key; you can also add this during instantiation.\n$filter->setEnvelopeKey('/key/from/encoder/envelope_key.pem');\n\n\n\nIf encyption used a passphrase, you'll need to provide that as well:\n\n\n// Use openssl and provide a private key\n$filter = new Zend\\Filter\\Decrypt([\n   'adapter' => 'openssl',\n   'passphrase' => 'enter here the passphrase for the private key',\n   'private' => '/path/to/mykey/private.pem'\n]);\n\n// Add the envelope key; you can also add this during instantiation.\n$filter->setEnvelopeKey('/key/from/encoder/envelope_key.pem');\n\n\n\nFinally, you can decode the content.\n\n\nOur complete example for decrypting the previously encrypted content looks like\nthis:\n\n\n// Use openssl and provide a private key\n$filter = new Zend\\Filter\\Decrypt([\n   'adapter' => 'openssl',\n   'passphrase' => 'enter here the passphrase for the private key',\n   'private' => '/path/to/mykey/private.pem'\n]);\n\n// Add the envelope key; you can also add this during instantiation.\n$filter->setEnvelopeKey('/key/from/encoder/envelope_key.pem');\n\n$decrypted = $filter->filter('encoded_text_normally_unreadable');\nprint $decrypted;\n\n\n\nHtmlEntities\n\n\nReturns the string \n$value\n, converting characters to their corresponding HTML\nentity equivalents when possible.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\HtmlEntities\n:\n\n\n\n\nquotestyle\n: Equivalent to the PHP \nhtmlentities()\n native function parameter\n  \nquote_style\n.  This allows you to define what will be done with 'single' and\n  \"double\" quotes. The following constants are accepted: \nENT_COMPAT\n,\n  \nENT_QUOTES\n, and \nENT_NOQUOTES\n, with the default being \nENT_COMPAT\n.\n\n\ncharset\n: Equivalent to the PHP \nhtmlentities()\n native function parameter\n  \ncharset\n. This defines the character set to be used in filtering. Unlike the\n  PHP native function, the default is 'UTF-8'. See the \nPHP htmlentities\n  manual\n for a list of supported character sets.\n\n\n\n\nThis option can also be set via the \n$options\n parameter as a Traversable\n  object or array. The option key will be accepted as either \ncharset\n or\n  \nencoding\n.\n- \ndoublequote\n: Equivalent to the PHP \nhtmlentities()\n native function\n  parameter \ndouble_encode\n. If set to \nfalse\n, existing HTML entities will not\n  be encoded. The default is to convert everything (\ntrue\n).\n\n\nThis option must be set via the \n$options\n parameter or the\n  \nsetDoubleEncode()\n method.\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\HtmlEntities();\n\nprint $filter->filter('<');\n\n\n\nQuote Style\n\n\nZend\\Filter\\HtmlEntities\n allows changing the quote style used. This can be useful when you want to\nleave double, single, or both types of quotes un-filtered.\n\n\n$filter = new Zend\\Filter\\HtmlEntities(['quotestyle' => ENT_QUOTES]);\n\n$input = \"A 'single' and \" . '\"double\"';\nprint $filter->filter($input);\n\n\n\nThe above example returns \nA &#039;single&#039; and &quot;double&quot;\n. Notice\nthat 'single' as well as \"double\" quotes are filtered.\n\n\n$filter = new Zend\\Filter\\HtmlEntities(['quotestyle' => ENT_COMPAT]);\n\n$input = \"A 'single' and \" . '\"double\"';\nprint $filter->filter($input);\n\n\n\nThe above example returns \nA 'single' and &quot;double&quot;\n. Notice that\n\"double\" quotes are filtered while 'single' quotes are not altered.\n\n\n$filter = new Zend\\Filter\\HtmlEntities(['quotestyle' => ENT_NOQUOTES]);\n\n$input = \"A 'single' and \" . '\"double\"';\nprint $filter->filter($input);\n\n\n\nThe above example returns \nA 'single' and \"double\"\n. Notice that neither\n\"double\" or 'single' quotes are altered.\n\n\nHelper Methods\n\n\nTo change or retrieve the \nquotestyle\n after instantiation, the two methods\n\nsetQuoteStyle()\n and \ngetQuoteStyle()\n may be used respectively.\n\nsetQuoteStyle()\n accepts one parameter, \n$quoteStyle\n, which accepts one of the\nconstants \nENT_COMPAT\n, \nENT_QUOTES\n, or \nENT_NOQUOTES\n.\n\n\n$filter = new Zend\\Filter\\HtmlEntities();\n\n$filter->setQuoteStyle(ENT_QUOTES);\nprint $filter->getQuoteStyle(ENT_QUOTES);\n\n\n\nTo change or retrieve the \ncharset\n after instantiation, the two methods\n\nsetCharSet()\n and \ngetCharSet()\n may be used respectively. \nsetCharSet()\n\naccepts one parameter, \n$charSet\n. See the \nPHP htmlentities manual\npage\n for a list of supported character sets.\n\n\n$filter = new Zend\\Filter\\HtmlEntities();\n\n$filter->setQuoteStyle(ENT_QUOTES);\nprint $filter->getQuoteStyle(ENT_QUOTES);\n\n\n\nTo change or retrieve the \ndoublequote\n option after instantiation, the two methods\n\nsetDoubleQuote()\n and \ngetDoubleQuote()\n may be used respectively. \nsetDoubleQuote()\n accepts one\nboolean parameter, \n$doubleQuote\n.\n\n\n$filter = new Zend\\Filter\\HtmlEntities();\n\n$filter->setQuoteStyle(ENT_QUOTES);\nprint $filter->getQuoteStyle(ENT_QUOTES);\n\n\n\nToFloat\n\n\n\n\nSince 2.9.0\n\n\n\n\nZend\\Filter\\ToFloat\n allows you to transform a scalar value into a float.\n\n\nSupported Options\n\n\nThere are no additional options for \nZend\\Filter\\ToFloat\n.\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\ToFloat();\n\nprint $filter->filter('-4.4');\n\n\n\nThis will return \n-4.4\n (as a float).\n\n\nToInt\n\n\nZend\\Filter\\ToInt\n allows you to transform a scalar value into an integer.\n\n\nSupported Options\n\n\nThere are no additional options for \nZend\\Filter\\ToInt\n.\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\ToInt();\n\nprint $filter->filter('-4 is less than 0');\n\n\n\nThis will return '-4'.\n\n\nMigration from 2.0-2.3 to 2.4+\n\n\nVersion 2.4 adds support for PHP 7. In PHP 7, \nint\n is a reserved keyword, which required renaming\nthe \nInt\n filter. If you were using the \nInt\n filter directly previously, you will now receive an\n\nE_USER_DEPRECATED\n notice on instantiation. Please update your code to refer to the \nToInt\n class\ninstead.\n\n\nUsers pulling their \nInt\n filter instance from the filter plugin manager receive a \nToInt\n instance\ninstead starting in 2.4.0.\n\n\nToNull\n\n\nThis filter will change the given input to be \nNULL\n if it meets specific\ncriteria. This is often necessary when you work with databases and want to have\na \nNULL\n value instead of a boolean or any other type.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\ToNull\n:\n\n\n\n\ntype\n: The variable type which should be supported.\n\n\n\n\nDefault Behavior\n\n\nPer default this filter works like PHP's \nempty()\n method; in other words, if\n\nempty()\n returns a boolean \nTRUE\n, then a \nNULL\n value will be returned.\n\n\n$filter = new Zend\\Filter\\ToNull();\n$value  = '';\n$result = $filter->filter($value);\n// returns null instead of the empty string\n\n\n\nThis means that without providing any configuration, \nZend\\Filter\\ToNull\n will\naccept all input types and return \nNULL\n in the same cases as \nempty()\n.\n\n\nAny other value will be returned as is, without any changes.\n\n\nChanging the Default Behavior\n\n\nSometimes it's not enough to filter based on \nempty()\n. Therefore\n\nZend\\Filter\\ToNull\n allows you to configure which types will be converted, and\nwhich not.\n\n\nThe following types can be handled:\n\n\n\n\nboolean\n: Converts a boolean \nFALSE\n value to \nNULL\n.\n\n\ninteger\n: Converts an integer \n0\n value to \nNULL\n.\n\n\nempty_array\n: Converts an empty \narray\n to \nNULL\n.\n\n\nfloat\n: Converts an float \n0.0\n value to \nNULL\n.\n\n\nstring\n: Converts an empty string \n''\n to \nNULL\n.\n\n\nzero\n: Converts a string containing the single character zero (\n'0'\n) to \nNULL\n.\n\n\nall\n: Converts all above types to \nNULL\n. (This is the default behavior.)\n\n\n\n\nThere are several ways to select which of the above types are filtered. You can\ngive one or multiple types and add them, you can give an array, you can use\nconstants, or you can give a textual string.  See the following examples:\n\n\n// converts false to null\n$filter = new Zend\\Filter\\ToNull(Zend\\Filter\\ToNull::BOOLEAN);\n\n// converts false and 0 to null\n$filter = new Zend\\Filter\\ToNull(\n    Zend\\Filter\\ToNull::BOOLEAN + Zend\\Filter\\ToNull::INTEGER\n);\n\n// converts false and 0 to null\n$filter = new Zend\\Filter\\ToNull([\n    Zend\\Filter\\ToNull::BOOLEAN,\n    Zend\\Filter\\ToNull::INTEGER\n]);\n\n// converts false and 0 to null\n$filter = new Zend\\Filter\\ToNull([\n    'boolean',\n    'integer',\n]);\n\n\n\nYou can also give a \nTraversable\n or an array to set the wished types. To set\ntypes afterwards use \nsetType()\n.\n\n\nMigration from 2.0-2.3 to 2.4+\n\n\nVersion 2.4 adds support for PHP 7. In PHP 7, \nnull\n is a reserved keyword, which required renaming\nthe \nNull\n filter. If you were using the \nNull\n filter directly previously, you will now receive an\n\nE_USER_DEPRECATED\n notice on instantiation. Please update your code to refer to the \nToNull\n class\ninstead.\n\n\nUsers pulling their \nNull\n filter instance from the filter plugin manager receive a \nToNull\n\ninstance instead starting in 2.4.0.\n\n\nNumberFormat\n\n\nThe \nNumberFormat\n filter can be used to return locale-specific number and percentage strings. It\nextends the \nNumberParse\n filter, which acts as wrapper for the \nNumberFormatter\n class within the\nInternationalization extension (Intl).\n\n\nThis filter is part of the zend-i18n package; you will need to include that\npackage in your application to use it.\n\n\nSupported Options\n\n\nThe following options are supported for \nNumberFormat\n:\n\n\nNumberFormat([ string $locale [, int $style [, int $type ]]])\n\n\n\n\n\n\n\n$locale\n: (Optional) Locale in which the number would be formatted (locale\n  name, e.g. \nen_US\n). If unset, it will use the default locale\n  (\nLocale::getDefault()\n). Methods for getting/setting the locale are also\n  available: \ngetLocale()\n and \nsetLocale()\n.\n\n\n\n\n\n\n$style\n: (Optional) Style of the formatting, one of the\n  \nformat style constants\n.\n  If unset, it will use \nNumberFormatter::DEFAULT_STYLE\n as the default style.\n  Methods for getting/setting the format style are also available: \ngetStyle()\n\n  and \nsetStyle()\n.\n\n\n\n\n\n\n$type\n: (Optional) The \nformatting type\n\n  to use. If unset, it will use \nNumberFormatter::TYPE_DOUBLE\n as the default\n  type. Methods for getting/setting the format type are also available:\n  \ngetType()\n and \nsetType()\n.\n\n\n\n\n\n\nBasic Usage\n\n\n$filter = new \\Zend\\I18n\\Filter\\NumberFormat('de_DE');\necho $filter->filter(1234567.8912346);\n// Returns '1.234.567,891'\n\n$filter = new \\Zend\\I18n\\Filter\\NumberFormat('en_US', NumberFormatter::PERCENT);\necho $filter->filter(0.80);\n// Returns '80%'\n\n$filter = new \\Zend\\I18n\\Filter\\NumberFormat('fr_FR', NumberFormatter::SCIENTIFIC);\necho $filter->filter(0.00123456789);\n// Returns '1,23456789E-3'\n\n\n\nNumberParse\n\n\nThe \nNumberParse\n filter can be used to parse a number from a string. It acts as\na wrapper for the \nNumberFormatter\n class within the Internationalization\nextension (Intl).\n\n\nThis filter is part of the zend-i18n package; you will need to include that\npackage in your application to use it.\n\n\nSupported Options\n\n\nThe following options are supported for \nNumberParse\n:\n\n\nNumberParse([ string $locale [, int $style [, int $type ]]])\n\n\n\n\n\n\n\n$locale\n: (Optional) Locale in which the number would be parsed (locale name,\n  e.g. \nen_US\n). If unset, it will use the default locale\n  (\nLocale::getDefault()\n). Methods for getting/setting the locale are also\n  available: \ngetLocale()\n and \nsetLocale()\n.\n\n\n\n\n\n\n$style\n: (Optional) Style of the parsing, one of the\n  \nformat style constants\n.\n  If unset, it will use \nNumberFormatter::DEFAULT_STYLE\n as the default style.\n  Methods for getting/setting the parse style are also available: \ngetStyle()\n\n  and \nsetStyle()\n.\n\n\n\n\n\n\n$type\n: (Optional) The \nparsing type\n\n  to use. If unset, it will use \nNumberFormatter::TYPE_DOUBLE\n as the default\n  type. Methods for getting/setting the parse type are also available:\n  \ngetType()\n and \nsetType()\n.\n\n\n\n\n\n\nBasic Usage\n\n\n$filter = new \\Zend\\I18n\\Filter\\NumberParse('de_DE');\necho $filter->filter('1.234.567,891');\n// Returns 1234567.8912346\n\n$filter = new \\Zend\\I18n\\Filter\\NumberParse('en_US', NumberFormatter::PERCENT);\necho $filter->filter('80%');\n// Returns 0.80\n\n$filter = new \\Zend\\I18n\\Filter\\NumberParse('fr_FR', NumberFormatter::SCIENTIFIC);\necho $filter->filter('1,23456789E-3');\n// Returns 0.00123456789\n\n\n\nPregReplace\n\n\nZend\\Filter\\PregReplace\n performs a search using regular expressions and replaces all found\nelements.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\PregReplace\n:\n\n\n\n\npattern\n: The pattern to search for.\n\n\nreplacement\n: The string which to use as a replacement for the matches; this\n  can optionally contain placeholders for matched groups in the search pattern.\n\n\n\n\nBasic Usage\n\n\nTo use this filter properly, you must give both options listed above.\n\n\nThe \npattern\n option has to be given to set the pattern to search for. It can be\na string for a single pattern, or an array of strings for multiple patterns.\n\n\nThe \nreplacement\n option indicates the string to replace matches with, and can\ncontain placeholders for matched groups from the search \npattern\n. The value may\nbe a string replacement, or an array of string replacements.\n\n\n$filter = new Zend\\Filter\\PregReplace([\n    'pattern'     => '/bob/',\n    'replacement' => 'john',\n]);\n$input  = 'Hi bob!';\n\n$filter->filter($input);\n// returns 'Hi john!'\n\n\n\nYou can also use \nsetPattern()\n to set the pattern(s), and \nsetReplacement()\n set\nthe replacement(s).\n\n\n$filter = new Zend\\Filter\\PregReplace();\n$filter\n    ->setPattern(array('bob', 'Hi'))\n    ->setReplacement(array('john', 'Bye'));\n$input = 'Hi bob!';\n\n$filter->filter($input);\n// returns 'Bye john!'\n\n\n\nFor more complex usage, read the\n\nPCRE Pattern chapter of the PHP manual\n.\n\n\nRealPath\n\n\nThis filter will resolve given links and pathnames, and returns the canonicalized\nabsolute pathnames.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\RealPath\n:\n\n\n\n\nexists\n: This option defaults to \nTRUE\n, which validates that the given path\n  really exists.\n\n\n\n\nBasic Usage\n\n\nFor any given link or pathname, its absolute path will be returned. References\nto \n/./\n, \n/../\n and extra \n/\n sequences in the input path will be stripped. The\nresulting path will not have any symbolic links, \n/./\n, or \n/../\n sequences.\n\n\nZend\\Filter\\RealPath\n will return \nFALSE\n on failure, e.g. if the file does not exist. On BSD\nsystems \nZend\\Filter\\RealPath\n doesn't fail if only the last path component doesn't exist, while\nother systems will return \nFALSE\n.\n\n\n$filter = new Zend\\Filter\\RealPath();\n$path = '/www/var/path/../../mypath';\n$filtered = $filter->filter($path);\n\n// returns '/www/mypath'\n\n\n\nNon-Existing Paths\n\n\nSometimes it is useful to get paths to files that do n0t exist; e.g., when you\nwant to get the real path for a path you want to create. You can then either\nprovide a \nFALSE\n \nexists\n value at initiation, or use \nsetExists()\n to set it.\n\n\n$filter = new Zend\\Filter\\RealPath(false);\n$path = '/www/var/path/../../non/existing/path';\n$filtered = $filter->filter($path);\n\n// returns '/www/non/existing/path'\n// even when file_exists or realpath would return false\n\n\n\nStringPrefix\n\n\n\n\nSince 2.9.0\n\n\n\n\nThis filter will add the provided prefix to scalar values.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\StringPrefix\n:\n\n\n\n\nprefix\n: The string prefix to add to values.\n\n\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\StringPrefix([\n    'prefix' => 'PHP-',\n]);\n\necho $filter->filter('MidCentral');\n\n\n\nThe above results in the string \nPHP-MidCentral\n.\n\n\nStringSuffix\n\n\n\n\nSince 2.9.0\n\n\n\n\nThis filter will add the provided suffix to scalar values.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\StringSuffix\n:\n\n\n\n\nsuffix\n: The string suffix to append to values.\n\n\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\StringSuffix([\n    'suffix' => '-PHP',\n]);\n\necho $filter->filter('MidCentral');\n\n\n\nThe above results in the string \nMidCentral-PHP\n.\n\n\nStringToLower\n\n\nThis filter converts any input to lowercase.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\StringToLower\n:\n\n\n\n\nencoding\n: This option can be used to set an encoding to use.\n\n\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\StringToLower();\n\nprint $filter->filter('SAMPLE');\n// returns \"sample\"\n\n\n\nHandling alternate encoding\n\n\nBy default, \nStringToLower\n will only handle characters from the locale of your\nserver; characters from other charsets will be ignored. If you have the mbstring\nextension, however, you can use the filter with other encodings.  Pass the\ndesired encoding when initiating the \nStringToLower\n filter, or use the\n\nsetEncoding()\n method to change it.\n\n\n// using UTF-8\n$filter = new Zend\\Filter\\StringToLower('UTF-8');\n\n// or give an array which can be useful when using a configuration\n$filter = new Zend\\Filter\\StringToLower(['encoding' => 'UTF-8']);\n\n// or do this afterwards\n$filter->setEncoding('ISO-8859-1');\n\n\n\n\n\nSetting invalid encodings\n\n\nBe aware that you will get an exception when:\n\n\n\n\nyou attempt to set an encoding and the mbstring extension is unavailable; or\n\n\nyou attempt to set an encoding unsupported by the mbstring extension.\n\n\n\n\n\n\nStringToUpper\n\n\nThis filter converts any input to UPPERCASE.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\StringToUpper\n:\n\n\n\n\nencoding\n: This option can be used to set the encoding to use.\n\n\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\StringToUpper();\n\nprint $filter->filter('Sample');\n// returns \"SAMPLE\"\n\n\n\nDifferent Encoded Strings\n\n\nLike the \nStringToLower\n filter, this filter will only handle characters\nsupported by your server locale, unless you have the mbstring extension enabled.\nUsing different character sets works the same as with \nStringToLower\n.\n\n\n$filter = new Zend\\Filter\\StringToUpper(['encoding' => 'UTF-8']);\n\n// or do this afterwards\n$filter->setEncoding('ISO-8859-1');\n\n\n\nStringTrim\n\n\nThis filter modifies a given string such that certain characters are removed\nfrom the beginning and end.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\StringTrim\n:\n\n\n\n\ncharlist\n: List of characters to remove from the beginning and end of the\n  string. If this is not set or is null, the default behavior will be invoked,\n  which is to remove only whitespace from the beginning and end of the string.\n\n\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\StringTrim();\n\nprint $filter->filter(' This is (my) content: ');\n\n\n\nThe above example returns \nThis is (my) content:\n. Notice that the whitespace\ncharacters have been removed.\n\n\nSpecifying alternate characters\n\n\n$filter = new Zend\\Filter\\StringTrim(':');\n// or new Zend\\Filter\\StringTrim(array('charlist' => ':'));\n\nprint $filter->filter(' This is (my) content:');\n\n\n\nThe above example returns \nThis is (my) content\n. Notice that the whitespace\ncharacters and colon are removed. You can also provide a \nTraversable\n or an\narray with a \ncharlist\n key. To set the desired character list after\ninstantiation, use the \nsetCharList()\n method. \ngetCharList()\n returns the\ncurrent character list.\n\n\nStripNewlines\n\n\nThis filter modifies a given string and removes all new line characters within\nthat string.\n\n\nSupported Options\n\n\nThere are no additional options for \nZend\\Filter\\StripNewlines\n:\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\StripNewlines();\n\nprint $filter->filter(' This is (my)``\\n\\r``content: ');\n\n\n\nThe above example returns \nThis is (my) content:\n. Notice that all newline\ncharacters have been removed.\n\n\nStripTags\n\n\nThis filter can strip XML and HTML tags from given content.\n\n\n\n\nZend\\Filter\\StripTags is potentially insecure\n\n\nBe warned that \nZend\\\\Filter\\\\StripTags\n should only be used to strip \nall\n\navailable tags.  Using \nZend\\\\Filter\\\\StripTags\n to make your site secure by\nstripping \nsome\n unwanted tags will lead to unsecure and dangerous code,\nincluding potential XSS vectors.\n\n\nFor a fully secure solution that allows selected filtering of HTML tags, use\neither Tidy or HtmlPurifier.\n\n\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\StripTags\n:\n\n\n\n\nallowAttribs\n: This option sets the attributes which are accepted. All other\n  attributes are stripped from the given content.\n\n\nallowTags\n: This option sets the tags which are accepted. All other tags will\n  be stripped from; the given content.\n\n\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\StripTags();\n\nprint $filter->filter('<B>My content</B>');\n\n\n\nThe result will be the stripped content \nMy content\n.\n\n\nWhen the content contains broken or partial tags, any content following the\nopening tag will be completely removed:\n\n\n$filter = new Zend\\Filter\\StripTags();\n\nprint $filter->filter('This contains <a href=\"http://example.com\">no ending tag');\n\n\n\nThe above will return \nThis contains\n, with the rest being stripped.\n\n\nAllowing Defined Tags\n\n\nZend\\Filter\\StripTags\n allows stripping all but a whitelist of tags. As an\nexample, this can be used to strip all markup except for links:\n\n\n$filter = new Zend\\Filter\\StripTags(['allowTags' => 'a']);\n\n$input  = \"A text with <br/> a <a href='link.com'>link</a>\";\nprint $filter->filter($input);\n\n\n\nThe above will return \nA text with a <a href='link.com'>link</a>\n;\nit strips all tags but the link. By providing an array, you can specify multiple\ntags at once.\n\n\n\n\nWarning\n\n\nDo not use this feature to secure content. This component does not replace the\nuse of a properly configured html filter.\n\n\n\n\nAllowing Defined Attributes\n\n\nYou can also strip all but a whitelist of attributes from a tag:\n\n\n$filter = new Zend\\Filter\\StripTags([\n    'allowTags' => 'img',\n    'allowAttribs' => 'src',\n]);\n\n$input  = \"A text with <br/> a <img src='picture.com' width='100'>picture</img>\";\nprint $filter->filter($input);\n\n\n\nThe above will return \nA text with a <img src='picture.com'>picture</img>\n; it\nstrips all tags but \n<img>\n, and all attributes but \nsrc\n from those tags.By\nproviding an array you can set multiple attributes at once.\n\n\nAllow specific tags with specific attributes\n\n\nYou can also pass the tag whitelist as a set of tag/attribute values. Each key\nwill be an allowed tag, pointing to a list of whitelisted attributes for that\ntag.\n\n\n$allowedElements = [\n    'img' => [\n        'src',\n        'width'\n    ],\n    'a' => [\n        'href'\n    ]\n];\n$filter = new Zend\\Filter\\StripTags($allowedElements);\n\n$input = \"A text with <br/> a <img src='picture.com' width='100'>picture</img> click \"\n    . \"<a href='http://picture.com/zend' id='hereId'>here</a>!\";\nprint $filter->filter($input);\n\n\n\nThe above will return \nA text with a <img src='picture.com'\nwidth='100'>picture</img> click <a href='<http://picture.com/zend>'>here</a>!\n\nas the result.\n\n\nUriNormalize\n\n\nThis filter sets the scheme on a URI if the scheme is missing.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\UriNormalize\n:\n\n\n\n\ndefaultScheme\n: This option can be used to set the default scheme to use when\n  parsing scheme-less URIs.\n\n\nenforcedScheme\n: Set a URI scheme to enforce on schemeless URIs.\n\n\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\UriNormalize(array(\n    'enforcedScheme' => 'https'\n));\n\necho $filter->filter('www.example.com');\n\n\n\nThe above results in the string \nhttps://www.example.com\n.\n\n\nWhitelist\n\n\nThis filter will return \nnull\n if the value being filtered is not present the\nfilter's allowed list of values. If the value is present, it will return that\nvalue.\n\n\nFor the opposite functionality see the \nBlacklist\n filter.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\Whitelist\n:\n\n\n\n\nstrict\n: Uses strict mode for comparisons; passed to \nin_array()\n's third argument.\n\n\nlist\n: An array of allowed values.\n\n\n\n\nBasic Usage\n\n\n$whitelist = new \\Zend\\Filter\\Whitelist([\n    'list' => ['allowed-1', 'allowed-2']\n]);\necho $whitelist->filter('allowed-2');   // => 'allowed-2'\necho $whitelist->filter('not-allowed'); // => null",
            "title": "Standard Filters"
        },
        {
            "location": "/standard-filters/#standard-filter-classes",
            "text": "zend-filter comes with a standard set of filters, available for immediate use.",
            "title": "Standard Filter Classes"
        },
        {
            "location": "/standard-filters/#alnum",
            "text": "The  Alnum  filter can be used to return only alphabetic characters and digits\nin the unicode \"letter\" and \"number\" categories, respectively. All other\ncharacters are suppressed.  This filter is part of the zend-i18n package; you will need to include that\npackage in your application to use it.",
            "title": "Alnum"
        },
        {
            "location": "/standard-filters/#supported-options",
            "text": "The following options are supported for  Alnum :  Alnum([ boolean $allowWhiteSpace [, string $locale ]])    $allowWhiteSpace : If set to true, then whitespace characters are allowed.\n  Otherwise they are suppressed. Default is  false  (whitespace is not allowed).\n  Methods for getting/setting the  allowWhiteSpace  option are also available:\n   getAllowWhiteSpace()  and  setAllowWhiteSpace() .    $locale : The locale string used in identifying the characters to filter\n  (locale name, e.g.  en_US ). If unset, it will use the default locale\n  ( Locale::getDefault() ). Methods for getting/setting the locale are also\n  available:  getLocale()  and  setLocale() .",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage",
            "text": "// Default settings, deny whitespace\n$filter = new \\Zend\\I18n\\Filter\\Alnum();\necho $filter->filter('This is (my) content: 123');\n// Returns 'Thisismycontent123'\n\n// First param in constructor is $allowWhiteSpace\n$filter = new \\Zend\\I18n\\Filter\\Alnum(true);\necho $filter->filter('This is (my) content: 123');\n// Returns 'This is my content 123'",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#supported-languages",
            "text": "Alnum  works on almost all languages, except: Chinese, Japanese and Korean.\nWithin these languages, the english alphabet is used instead of the characters\nfrom these languages. The language itself is detected using the  Locale \nclass.",
            "title": "Supported languages"
        },
        {
            "location": "/standard-filters/#alpha",
            "text": "The  Alpha  filter can be used to return only alphabetic characters in the unicode \"letter\"\ncategory. All other characters are suppressed.  This filter is part of the zend-i18n package; you will need to include that\npackage in your application to use it.",
            "title": "Alpha"
        },
        {
            "location": "/standard-filters/#supported-options_1",
            "text": "The following options are supported for  Alpha :  Alpha([ boolean $allowWhiteSpace [, string $locale ]])    $allowWhiteSpace : If set to true then whitespace characters are allowed.\n  Otherwise they are suppressed. Default is  false  (whitespace is not allowed).\n  Methods for getting/setting the allowWhiteSpace option are also available:\n   getAllowWhiteSpace()  and  setAllowWhiteSpace() .    $locale : The locale string used in identifying the characters to filter\n  (locale name, e.g.  en_US ). If unset, it will use the default locale\n  ( Locale::getDefault() ).  Methods for getting/setting the locale are also\n  available:  getLocale()  and  setLocale() .",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_1",
            "text": "// Default settings, deny whitespace\n$filter = new \\Zend\\I18n\\Filter\\Alpha();\necho $filter->filter('This is (my) content: 123');\n// Returns 'Thisismycontent'\n\n// Allow whitespace\n$filter = new \\Zend\\I18n\\Filter\\Alpha(true);\necho $filter->filter('This is (my) content: 123');\n// Returns 'This is my content '",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#supported-languages_1",
            "text": "Alpha  works on almost all languages, except: Chinese, Japanese and Korean.\nWithin these languages, the english alphabet is used instead of the characters\nfrom these languages. The language itself is detected using the  Locale \nclass.",
            "title": "Supported languages"
        },
        {
            "location": "/standard-filters/#basename",
            "text": "Zend\\Filter\\BaseName  allows you to filter a string which contains the path to\na file, and it will return the base name of this file.",
            "title": "BaseName"
        },
        {
            "location": "/standard-filters/#supported-options_2",
            "text": "There are no additional options for  Zend\\Filter\\BaseName .",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_2",
            "text": "$filter = new Zend\\Filter\\BaseName();\n\nprint $filter->filter('/vol/tmp/filename');  This will return 'filename'.  $filter = new Zend\\Filter\\BaseName();\n\nprint $filter->filter('/vol/tmp/filename.txt');  This will return ' filename.txt '.",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#blacklist",
            "text": "This filter will return  null  if the value being filtered is present in the filter's list of\nvalues. If the value is not present, it will return that value.  For the opposite functionality, see the  Whitelist  filter .",
            "title": "Blacklist"
        },
        {
            "location": "/standard-filters/#supported-options_3",
            "text": "The following options are supported for  Zend\\Filter\\Blacklist :   strict : Uses strict mode when comparing; passed to  in_array() 's third argument.  list : An array of forbidden values.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_3",
            "text": "$blacklist = new \\Zend\\Filter\\Blacklist([\n    'list' => ['forbidden-1', 'forbidden-2']\n]);\necho $blacklist->filter('forbidden-1'); // => null\necho $blacklist->filter('allowed');     // => 'allowed'",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#boolean",
            "text": "This filter changes a given input to be a  BOOLEAN  value. This is often useful when working with\ndatabases or when processing form values.",
            "title": "Boolean"
        },
        {
            "location": "/standard-filters/#supported-options_4",
            "text": "The following options are supported for  Zend\\Filter\\Boolean :   casting : When this option is set to  TRUE , then any given input will be\n  cast to boolean.  This option defaults to  TRUE .  translations : This option sets the translations which will be used to detect localized input.  type : The  type  option sets the boolean type which should be used. Read\n  the following for details.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#default-behavior",
            "text": "By default, this filter works by casting the input to a  BOOLEAN  value; in other words, it operates\nin a similar fashion to calling  (boolean) $value .  $filter = new Zend\\Filter\\Boolean();\n$value  = '';\n$result = $filter->filter($value);\n// returns false  This means that without providing any configuration,  Zend\\Filter\\Boolean  accepts all input types\nand returns a  BOOLEAN  just as you would get by type casting to  BOOLEAN .",
            "title": "Default Behavior"
        },
        {
            "location": "/standard-filters/#changing-the-default-behavior",
            "text": "Sometimes, casting with  (boolean)  will not suffice.  Zend\\Filter\\Boolean \nallows you to configure specific types to convert, as well as which to omit.  The following types can be handled (in this precedence order):   localized : Converts any string as mapped (case sensitive) in the  translations  option.  false : Converts a string equal to the word \"false\" (case insensitive) to boolean  FALSE .  null : Converts a  NULL  value to  FALSE .  array : Converts an empty  array  to  FALSE .  zero : Converts a string to  FALSE  if it equates to  '0'  after type juggling.  string : Converts an empty string  ''  to  FALSE .  float : Converts a float  0.0  value to  FALSE .  integer : Converts an integer  0  value to  FALSE .  boolean : Returns a boolean value as is.   There are 2 additional special types:   all : Converts all above types to  BOOLEAN . The same as setting all above types.  php : Converts all above types to  BOOLEAN  except  localized  or  false . The same as setting all above types except  localized  or  false .   All other given values will return  TRUE  by default.  There are several ways to select which of the above types are filtered. You can\ngive one or multiple types and add them, you can give an array, you can use\nconstants, or you can give a textual string.  See the following examples:  // converts 0 to false\n$filter = new Zend\\Filter\\Boolean(Zend\\Filter\\Boolean::TYPE_INTEGER);\n\n// converts 0 and '0' to false\n$filter = new Zend\\Filter\\Boolean(\n    Zend\\Filter\\Boolean::TYPE_INTEGER + Zend\\Filter\\Boolean::TYPE_ZERO_STRING\n);\n\n// converts 0 and '0' to false\n$filter = new Zend\\Filter\\Boolean([\n    'type' => [\n        Zend\\Filter\\Boolean::TYPE_INTEGER,\n        Zend\\Filter\\Boolean::TYPE_ZERO_STRING,\n    ],\n]);\n\n// converts 0 and '0' to false\n$filter = new Zend\\Filter\\Boolean([\n    'type' => [\n        'integer',\n        'zero',\n    ],\n]);  You can also give an instance of  Zend\\Config\\Config  to set the desired types.\nTo set types after instantiation, use the  setType()  method.",
            "title": "Changing the Default Behavior"
        },
        {
            "location": "/standard-filters/#localized-booleans",
            "text": "As mentioned previously,  Zend\\Filter\\Boolean  can also recognise localized \"yes\" and \"no\" strings.\nThis means that you can ask your customer in a form for \"yes\" or \"no\" within his native language and Zend\\Filter\\Boolean  will convert the response to the appropriate boolean value.  To set the translation and the corresponding value, you can use the  translations  option or the\nmethod  setTranslations . The translations must be set for any values you wish to map to boolean values.  $filter = new Zend\\Filter\\Boolean([\n    'type'         => Zend\\Filter\\Boolean::TYPE_LOCALIZED,\n    'translations' => [\n        'ja'   => true,\n        'nein' => false,\n        'yes'  => true,\n        'no'   => false,\n    ],\n]);\n\n// returns false\n$result = $filter->filter('nein');\n\n// returns true\n$result = $filter->filter('yes');",
            "title": "Localized Booleans"
        },
        {
            "location": "/standard-filters/#disable-casting",
            "text": "Sometimes it is necessary to recognise only  TRUE  or  FALSE  and return all\nother values without changes.  Zend\\Filter\\Boolean  allows you to do this by\nsetting the  casting  option to  FALSE .  In this case  Zend\\Filter\\Boolean  will work as described in the following\ntable, which shows which values return  TRUE  or  FALSE . All other given values\nare returned without change when  casting  is set to  FALSE     Type Constant  Type String  True  False      Zend\\Filter\\Boolean::TYPE_BOOLEAN  boolean  TRUE  FALSE    Zend\\Filter\\Boolean::TYPE_EMPTY_ARRAY  array   []    Zend\\Filter\\Boolean::TYPE_FALSE_STRING  false  'false'  (case insensitive)  'true'  (case insensitive)    Zend\\Filter\\Boolean::TYPE_FLOAT  float  1.0  0.0    Zend\\Filter\\Boolean::TYPE_INTEGER  integer  1  0    Zend\\Filter\\Boolean::TYPE_NULL  null   NULL    Zend\\Filter\\Boolean::TYPE_STRING  string   ''    Zend\\Filter\\Boolean::TYPE_ZERO_STRING  zero  '1'  '0'     The following example shows the behavior when changing the  casting  option:  $filter = new Zend\\Filter\\Boolean([\n    'type'    => Zend\\Filter\\Boolean::TYPE_ALL,\n    'casting' => false,\n]);\n\n// returns false\n$result = $filter->filter(0);\n\n// returns true\n$result = $filter->filter(1);\n\n// returns the value\n$result = $filter->filter(2);",
            "title": "Disable Casting"
        },
        {
            "location": "/standard-filters/#callback",
            "text": "This filter allows you to use own methods in conjunction with  Zend\\Filter . You\ndon't have to create a new filter when you already have a method which does the\njob.",
            "title": "Callback"
        },
        {
            "location": "/standard-filters/#supported-options_5",
            "text": "The following options are supported for  Zend\\Filter\\Callback :   callback : This sets the callback which should be used.  callback_params : This property sets the options which are used when the\n  callback is processed.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_4",
            "text": "The usage of this filter is quite simple. In this example, we want to create a\nfilter which reverses a string:  $filter = new Zend\\Filter\\Callback('strrev');\n\nprint $filter->filter('Hello!');\n// returns \"!olleH\"  As you can see it's really simple to use a callback to define custom filters. It\nis also possible to use a method, which is defined within a class, by giving an\narray as the callback:  class MyClass\n{\n    public static function reverse($param);\n}\n\n// The filter definition\n$filter = new Zend\\Filter\\Callback(array('MyClass', 'reverse'));\nprint $filter->filter('Hello!');  As of PHP 5.5 you can use ::class resolution for given callback class:  class MyClass\n{\n    public function __invoke($param);\n}\n\n// The filter definition\n$filter = new Zend\\Filter\\Callback(MyClass::class);\nprint $filter->filter('Hello!');  To get the actual set callback use  getCallback()  and to set another callback\nuse  setCallback() .",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#possible-exceptions",
            "text": "You should note that defining a callback method which can not be called will\nraise an exception.",
            "title": "Possible exceptions"
        },
        {
            "location": "/standard-filters/#default-parameters-within-a-callback",
            "text": "It is also possible to define default parameters, which are given to the called\nmethod as an array when the filter is executed. This array will be concatenated\nwith the value which will be filtered.  $filter = new Zend\\Filter\\Callback([\n    'callback' => 'MyMethod',\n    'options'  => ['key' => 'param1', 'key2' => 'param2']\n]);\n$filter->filter(['value' => 'Hello']);  Calling the above method definition manually would look like this:  $value = MyMethod('Hello', 'param1', 'param2');",
            "title": "Default Parameters Within a Callback"
        },
        {
            "location": "/standard-filters/#compress-and-decompress",
            "text": "These two filters are capable of compressing and decompressing strings, files, and directories.",
            "title": "Compress and Decompress"
        },
        {
            "location": "/standard-filters/#supported-options_6",
            "text": "The following options are supported for  Zend\\Filter\\Compress  and  Zend\\Filter\\Decompress :   adapter : The compression adapter which should be used. It defaults to  Gz .  options : Additional options which are given to the adapter at initiation.\n  Each adapter supports its own options.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#supported-compression-adapters",
            "text": "The following compression formats are supported by their own adapter:   Bz2  Gz  Lzf  Rar  Tar  Zip   Each compression format has different capabilities as described below. All\ncompression filters may be used in approximately the same ways, and differ\nprimarily in the options available and the type of compression they offer (both\nalgorithmically as well as string vs. file vs. directory)",
            "title": "Supported Compression Adapters"
        },
        {
            "location": "/standard-filters/#generic-handling",
            "text": "To create a compression filter, you need to select the compression format you want to use. The\nfollowing example takes the  Bz2  adapter. Details for all other adapters are described after\nthis section.  The two filters are basically identical, in that they utilize the same backends. Zend\\Filter\\Compress  should be used when you wish to compress items, and  Zend\\Filter\\Decompress \nshould be used when you wish to decompress items.  For instance, if we want to compress a string, we have to initialize  Zend\\Filter\\Compress  and\nindicate the desired adapter:  $filter = new Zend\\Filter\\Compress('Bz2');  To use a different adapter, you simply specify it to the constructor.  You may also provide an array of options or a  Traversable  object. If you do,\nprovide minimally the key \"adapter\", and then either the key \"options\" or\n\"adapterOptions\", both of which should be an array of options to provide to the\nadapter on instantiation.  $filter = new Zend\\Filter\\Compress([\n    'adapter' => 'Bz2',\n    'options' => [\n        'blocksize' => 8,\n    ],\n]);",
            "title": "Generic Handling"
        },
        {
            "location": "/standard-filters/#default-compression-adapter",
            "text": "When no compression adapter is given, then the  Gz  adapter will be used.   Decompression is essentially the same usage; we simply use the  Decompress \nfilter instead:  $filter = new Zend\\Filter\\Decompress('Bz2');  To get the compressed string, we have to give the original string. The filtered value is the\ncompressed version of the original string.  $filter     = new Zend\\Filter\\Compress('Bz2');\n$compressed = $filter->filter('Uncompressed string');\n// Returns the compressed string  Decompression works in reverse, accepting the compressed string, and returning\nthe original:  $filter     = new Zend\\Filter\\Decompress('Bz2');\n$compressed = $filter->filter('Compressed string');\n// Returns the original, uncompressed string",
            "title": "Default compression Adapter"
        },
        {
            "location": "/standard-filters/#note-on-string-compression",
            "text": "Not all adapters support string compression. Compression formats like  Rar \ncan only handle files and directories. For details, consult the section for\nthe adapter you wish to use.",
            "title": "Note on string compression"
        },
        {
            "location": "/standard-filters/#creating-an-archive",
            "text": "Creating an archive file works almost the same as compressing a string. However, in this case we\nneed an additional parameter which holds the name of the archive we want to create.  $filter = new Zend\\Filter\\Compress([\n    'adapter' => 'Bz2',\n    'options' => [\n        'archive' => 'filename.bz2',\n    ],\n]);\n$compressed = $filter->filter('Uncompressed string');\n// Returns true on success, and creates the archive file  In the above example, the uncompressed string is compressed, and is then written\ninto the given archive file.",
            "title": "Creating an Archive"
        },
        {
            "location": "/standard-filters/#existing-archives-will-be-overwritten",
            "text": "The content of any existing file will be overwritten when the given filename\nof the archive already exists.   When you want to compress a file, then you must give the name of the file with its path:  $filter = new Zend\\Filter\\Compress([\n    'adapter' => 'Bz2',\n    'options' => [\n        'archive' => 'filename.bz2'\n    ],\n]);\n$compressed = $filter->filter('C:\\temp\\compressme.txt');\n// Returns true on success and creates the archive file  You may also specify a directory instead of a filename. In this case the whole\ndirectory with all its files and subdirectories will be compressed into the\narchive:  $filter = new Zend\\Filter\\Compress([\n    'adapter' => 'Bz2',\n    'options' => [\n        'archive' => 'filename.bz2'\n    ],\n]);\n$compressed = $filter->filter('C:\\temp\\somedir');\n// Returns true on success and creates the archive file",
            "title": "Existing archives will be overwritten"
        },
        {
            "location": "/standard-filters/#do-not-compress-large-or-base-directories",
            "text": "You should never compress large or base directories like a complete partition.\nCompressing a complete partition is a very time consuming task which can lead\nto massive problems on your server when there is not enough space or your\nscript takes too much time.",
            "title": "Do not compress large or base directories"
        },
        {
            "location": "/standard-filters/#decompressing-an-archive",
            "text": "Decompressing an archive file works almost like compressing it. You must specify either the archive  parameter, or give the filename of the archive when you decompress the file.  $filter = new Zend\\Filter\\Decompress('Bz2');\n$decompressed = $filter->filter('filename.bz2');\n// Returns true on success and decompresses the archive file  Some adapters support decompressing the archive into another subdirectory. In\nthis case you can set the  target  parameter:  $filter = new Zend\\Filter\\Decompress([\n    'adapter' => 'Zip',\n    'options' => [\n        'target' => 'C:\\temp',\n    ]\n]);\n$decompressed = $filter->filter('filename.zip');\n// Returns true on success, and decompresses the archive file\n// into the given target directory",
            "title": "Decompressing an Archive"
        },
        {
            "location": "/standard-filters/#directories-to-extract-to-must-exist",
            "text": "When you want to decompress an archive into a directory, then the target\ndirectory must exist.",
            "title": "Directories to extract to must exist"
        },
        {
            "location": "/standard-filters/#bz2-adapter",
            "text": "The Bz2 Adapter can compress and decompress:   Strings  Files  Directories   This adapter makes use of PHP's Bz2 extension.  To customize compression, this adapter supports the following options:   archive : This parameter sets the archive file which should be used or created.  blocksize : This parameter sets the blocksize to use. It can be from '0' to\n  '9'. The default value is '4'.   All options can be set at instantiation or by using a related method; for example, the related\nmethods for 'blocksize' are  getBlocksize()  and  setBlocksize() . You can also use the setOptions()  method, which accepts an array of all options.",
            "title": "Bz2 Adapter"
        },
        {
            "location": "/standard-filters/#gz-adapter",
            "text": "The Gz Adapter can compress and decompress:   Strings  Files  Directories   This adapter makes use of PHP's Zlib extension.  To customize the compression this adapter supports the following options:   archive : This parameter sets the archive file which should be used or created.  level : This compression level to use. It can be from '0' to '9'. The default\n  value is '9'.  mode : There are two supported modes.  compress  and  deflate . The default\n  value is  compress .   All options can be set at initiation or by using a related method. For example, the related methods\nfor  level  are  getLevel()  and  setLevel() . You can also use the  setOptions()  method which\naccepts an array of all options.",
            "title": "Gz Adapter"
        },
        {
            "location": "/standard-filters/#lzf-adapter",
            "text": "The Lzf Adapter can compress and decompress:   Strings",
            "title": "Lzf Adapter"
        },
        {
            "location": "/standard-filters/#lzf-supports-only-strings",
            "text": "The Lzf adapter can not handle files and directories.   This adapter makes use of PHP's Lzf extension.  There are no options available to customize this adapter.",
            "title": "Lzf supports only strings"
        },
        {
            "location": "/standard-filters/#rar-adapter",
            "text": "The Rar Adapter can compress and decompress:   Files  Directories",
            "title": "Rar Adapter"
        },
        {
            "location": "/standard-filters/#rar-does-not-support-strings",
            "text": "The Rar Adapter can not handle strings.   This adapter makes use of PHP's Rar extension.",
            "title": "Rar does not support strings"
        },
        {
            "location": "/standard-filters/#rar-compression-not-supported",
            "text": "Due to restrictions with the Rar compression format, there is no compression\navailable for free. When you want to compress files into a new Rar archive,\nyou must provide a callback to the adapter that can invoke a Rar compression\nprogram.   To customize compression, this adapter supports the following options:   archive : This parameter sets the archive file which should be used or created.  callback : A callback which provides compression support to this adapter.  password : The password which has to be used for decompression.  target : The target where the decompressed files will be written to.   All options can be set at instantiation or by using a related method. For example, the related\nmethods for  target  are  getTarget()  and  setTarget() . You can also use the  setOptions()  method\nwhich accepts an array of all options.",
            "title": "Rar compression not supported"
        },
        {
            "location": "/standard-filters/#tar-adapter",
            "text": "The Tar Adapter can compress and decompress:   Files  Directories",
            "title": "Tar Adapter"
        },
        {
            "location": "/standard-filters/#tar-does-not-support-strings",
            "text": "The Tar Adapter can not handle strings.   This adapter makes use of PEAR's  Archive_Tar  component.  To customize compression, this adapter supports the following options:   archive : This parameter sets the archive file which should be used or created.  mode : A mode to use for compression. Supported are either  NULL , which\n  means no compression at all;  Gz , which makes use of PHP's Zlib extension;\n  and  Bz2 , which makes use of PHP's Bz2 extension. The default value is  NULL .  target : The target where the decompressed files will be written to.   All options can be set at instantiation or by using a related method. For\nexample, the related methods for  target  are  getTarget()  and  setTarget() .\nYou can also use the  setOptions()  method which accepts an array of all\noptions.",
            "title": "Tar does not support strings"
        },
        {
            "location": "/standard-filters/#directory-usage",
            "text": "When compressing directories with Tar, the complete file path is used. This\nmeans that created Tar files will not only have the subdirectory, but the\ncomplete path for the compressed file.",
            "title": "Directory usage"
        },
        {
            "location": "/standard-filters/#zip-adapter",
            "text": "The Zip Adapter can compress and decompress:   Strings  Files  Directories",
            "title": "Zip Adapter"
        },
        {
            "location": "/standard-filters/#zip-does-not-support-string-decompression",
            "text": "The Zip Adapter can not handle decompression to a string; decompression will\nalways be written to a file.   This adapter makes use of PHP's  Zip  extension.  To customize compression, this adapter supports the following options:   archive : This parameter sets the archive file which should be used or created.  target : The target where the decompressed files will be written to.   All options can be set at instantiation or by using a related method. For example, the related\nmethods for  target  are  getTarget()  and  setTarget() . You can also use the  setOptions()  method\nwhich accepts an array of all options.",
            "title": "Zip does not support string decompression"
        },
        {
            "location": "/standard-filters/#digits",
            "text": "Returns the string  $value , removing all but digits.",
            "title": "Digits"
        },
        {
            "location": "/standard-filters/#supported-options_7",
            "text": "There are no additional options for  Zend\\Filter\\Digits .",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_5",
            "text": "$filter = new Zend\\Filter\\Digits();\n\nprint $filter->filter('October 2012');  This returns \"2012\".  $filter = new Zend\\Filter\\Digits();\n\nprint $filter->filter('HTML 5 for Dummies');  This returns \"5\".",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#dir",
            "text": "Given a string containing a path to a file, this function will return the name of the directory.",
            "title": "Dir"
        },
        {
            "location": "/standard-filters/#supported-options_8",
            "text": "There are no additional options for  Zend\\Filter\\Dir .",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_6",
            "text": "$filter = new Zend\\Filter\\Dir();\n\nprint $filter->filter('/etc/passwd');  This returns  /etc .  $filter = new Zend\\Filter\\Dir();\n\nprint $filter->filter('C:/Temp/x');  This returns  C:/Temp .",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#encrypt-and-decrypt",
            "text": "These filters allow encrypting and decrypting any given string; they do so via\nthe use of adapters. Included adapters support  Zend\\Crypt\\BlockCipher  and\nPHP's OpenSSL extension.",
            "title": "Encrypt and Decrypt"
        },
        {
            "location": "/standard-filters/#supported-options_9",
            "text": "The following options are supported for  Zend\\Filter\\Encrypt  and Zend\\Filter\\Decrypt , and segregated by adapter.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#general-options",
            "text": "adapter : This sets the encryption adapter to use.  compression : If the encrypted value should be compressed. Default is no\n  compression.",
            "title": "General options"
        },
        {
            "location": "/standard-filters/#blockcipher-options",
            "text": "algorithm : The algorithm to use with  Zend\\Crypt\\Symmetric\\Mcrypt  (use the\n  the  getSupportedAlgorithms()  method of that class to determine what is\n  supported). If not set, it defaults to  aes , the Advanced Encryption Standard\n  (see the  zend-crypt BlockCipher documentation \n  for details).  key : The encryption key with which the input will be encrypted. You need the\n  same key for decryption.  mode : The encryption mode to use. It should be a\n   valid PHP mcrypt modes .\n  If not set, it defaults to 'cbc'.  mode_directory : The directory where the mode can be found. If not set, it\n  defaults to the path set within the  Mcrypt  extension.  vector : The initialization vector which shall be used. If not set, it will\n  be a random vector.",
            "title": "BlockCipher options"
        },
        {
            "location": "/standard-filters/#openssl-options",
            "text": "envelope : The encrypted envelope key from the user who encrypted the\n  content. You can either provide the path and filename of the key file, or just\n  the content of the key file itself. When the  package  option has been set,\n  then you can omit this parameter.  package : If the envelope key should be packed with the encrypted value.\n  Default is  FALSE .  private : The private key to use for encrypting the content. You can either\n  provide the path and filename of the key file, or just the content of the key\n  file itself.  public : The public key of the user for whom you want to provide the\n  encrypted content. You can either provide the path and filename of the key\n  file, or just the content of the key file itself.",
            "title": "OpenSSL options"
        },
        {
            "location": "/standard-filters/#adapter-usage",
            "text": "As these two encryption methodologies work completely different, the usage\nof the adapters differ. You have to select the adapter you want to use when\ninitiating the filter.  // Use the BlockCipher adapter\n$filter1 = new Zend\\Filter\\Encrypt(['adapter' => 'BlockCipher']);\n\n// Use the OpenSSL adapter\n$filter2 = new Zend\\Filter\\Encrypt(['adapter' => 'openssl']);  To set another adapter, you can use  setAdapter() ;  getAdapter()  will return\nthe currently composed adapter.  // Use the OpenSSL adapter\n$filter = new Zend\\Filter\\Encrypt();\n$filter->setAdapter('openssl');",
            "title": "Adapter Usage"
        },
        {
            "location": "/standard-filters/#default-adapter",
            "text": "When you do not supply the  adapter  option or do not call  setAdapter() , the BlockCipher  adapter will be used per default.",
            "title": "Default adapter"
        },
        {
            "location": "/standard-filters/#encryption-with-blockcipher",
            "text": "To encrypt a string using the  BlockCipher  adapter, you have to specify the\nencryption key by either calling the  setKey()  method or passing it to the\nconstructor.  // Use the default AES encryption algorithm\n$filter = new Zend\\Filter\\Encrypt(['adapter' => 'BlockCipher']);\n$filter->setKey('encryption key');\n\n// or\n// $filter = new Zend\\Filter\\Encrypt([\n//     'adapter' => 'BlockCipher',\n//     'key'     => 'encryption key'\n// ]);\n\n$encrypted = $filter->filter('text to be encrypted');\nprintf (\"Encrypted text: %s\\n\", $encrypted);  You can get and set the encryption values after construction using the getEncryption()  and  setEncryption()  methods:  // Use the default AES encryption algorithm\n$filter = new Zend\\Filter\\Encrypt(['adapter' => 'BlockCipher']);\n$filter->setKey('encryption key');\nvar_dump($filter->getEncryption());\n\n// Will print:\n//array(4) {\n//  [\"key_iteration\"]=>\n//  int(5000)\n//  [\"algorithm\"]=>\n//  string(3) \"aes\"\n//  [\"hash\"]=>\n//  string(6) \"sha256\"\n//  [\"key\"]=>\n//  string(14) \"encryption key\"\n//}",
            "title": "Encryption with BlockCipher"
        },
        {
            "location": "/standard-filters/#default-blockcipher-algorithm",
            "text": "The  BlockCipher  adapter uses the  Mcrypt  extension\nby default. That means you will need to install the Mcrypt module in your PHP\nenvironment.   If you don't specify an initialization Vector (salt or iv), the  BlockCipher  will\ngenerate a random value during each encryption. If you try to execute the\nfollowing code, the output will always be different (note that even if the output\nis always different, you can still decrypt it using the same key).  $key  = 'encryption key';\n$text = 'message to encrypt';\n\n// use the default adapter that is BlockCipher\n$filter = new \\Zend\\Filter\\Encrypt();\n$filter->setKey('encryption key');\nfor ($i = 0; $i < 10; $i++) {\n   printf(\"%d) %s\\n\", $i, $filter->filter($text));\n}  If you want to obtain the same output, you need to specify a fixed vector, using\nthe  setVector()  method. This following example always produces the same\nencryption output:  // use the default adapter that is BlockCipher\n$filter = new \\Zend\\Filter\\Encrypt();\n$filter->setKey('encryption key');\n$filter->setVector('12345678901234567890');\nprintf(\"%s\\n\", $filter->filter('message'));\n\n// output:\n//\n04636a6cb8276fad0787a2e187803b6557f77825d5ca6ed4392be702b9754bb3MTIzNDU2Nzg5MDEyMzQ1NgZ+zPwTGpV6gQqPKECinig=",
            "title": "Default BlockCipher algorithm"
        },
        {
            "location": "/standard-filters/#use-different-vectors",
            "text": "For security purposes, it's always better to use a different vector on each\nencryption. We suggest using  setVector()  only in exceptional circumstances.",
            "title": "Use different vectors"
        },
        {
            "location": "/standard-filters/#decryption-with-blockcipher",
            "text": "For decrypting content previously encrypted with  BlockCipher , you need to use\nthe same options used for encryption.  If you used only the encryption key, you can just use it to decrypt the content.\nAs soon as you have provided all options, decryption works the same as\nencryption.  $content = '04636a6cb8276fad0787a2e187803b6557f77825d5ca6ed4392be702b9754bb3MTIzNDU2Nzg5MDEyMzQ1NgZ+zPwTGpV6gQqPKECinig=';\n// use the default adapter (BlockCipher):\n$filter = new Zend\\Filter\\Decrypt();\n$filter->setKey('encryption key');\nprintf(\"Decrypt: %s\\n\", $filter->filter($content));\n\n// output:\n// Decrypt: message  Note that even if we did not specify the same vector, the  BlockCipher  is able\nto decrypt the message because the vector is stored in the encryption string\nitself (note that the vector can be stored in plaintext; it is not a secret, and\nonly used to improve the randomness of the encryption algorithm).",
            "title": "Decryption with BlockCipher"
        },
        {
            "location": "/standard-filters/#encryption-with-openssl",
            "text": "If you have installed the  OpenSSL  extension, you can also use the  OpenSSL \nadapter. You can get or set the public key either during instantiation, or later\nvia the  setPublicKey()  method. The private key can also be set after-the-fact\nvia the  setPrivateKey()  method.  // Use openssl and provide a private key\n$filter = new Zend\\Filter\\Encrypt([\n   'adapter' => 'openssl',\n   'private' => '/path/to/mykey/private.pem',\n]);\n\n// Add the private key separately:\n$filter->setPublicKey('/public/key/path/public.pem');",
            "title": "Encryption with OpenSSL"
        },
        {
            "location": "/standard-filters/#valid-keys-are-required",
            "text": "The  OpenSSL  adapter will not work with invalid or missing keys.   When you want to decode content encoded with a passphrase, you will not only\nneed the public key, but also the passphrase:  // Use openssl and provide a private key\n$filter = new Zend\\Filter\\Encrypt([\n   'adapter' => 'openssl',\n   'passphrase' => 'enter here the passphrase for the private key',\n   'private' => '/path/to/mykey/private.pem',\n   'public' => '/public/key/path/public.pem'\n]);  When providing the encrypted content to the recipient, you will also need to\nensure they have the passphrase and the envelope keys so they may decrypt the\nmessage. You can get the envelope keys using the  getEnvelopeKey()  method:  A complete example for encrypting content with  OpenSSL  looks like the\nfollowing:  // Use openssl and provide a private key\n$filter = new Zend\\Filter\\Encrypt([\n   'adapter' => 'openssl',\n   'passphrase' => 'enter here the passphrase for the private key',\n   'private' => '/path/to/mykey/private.pem',\n   'public' => '/public/key/path/public.pem'\n]);\n\n$encrypted = $filter->filter('text_to_be_encoded');\n$envelope  = $filter->getEnvelopeKey();\nprint $encrypted;\n\n// For decryption look at the Decrypt filter",
            "title": "Valid keys are required"
        },
        {
            "location": "/standard-filters/#simplified-usage-with-openssl",
            "text": "As noted in the previous section, you need to provide the envelope key to the\nrecipient in order for them to decrypt the message. This adds complexity,\nparticularly if you are encrypting multiple values.  To simplify usage, you can set the  package  option to  TRUE  when creating your Encrypt  instance (the default value is  FALSE ). This will return a value\ncontaining both the encrypted message  and  the envelope key:  // Use openssl and provide a private key\n$filter = new Zend\\Filter\\Encrypt([\n   'adapter' => 'openssl',\n   'private' => '/path/to/mykey/private.pem',\n   'public'  => '/public/key/path/public.pem',\n   'package' => true,\n]);\n\n$encrypted = $filter->filter('text_to_be_encoded');\nprint $encrypted;\n\n// For decryption look at the Decrypt filter  Now the returned value contains the encrypted value and the envelope. You don't\nneed to fetch the envelope key separately.  However, there is one negative aspect to this: the encrypted value can now only\nbe decrypted by using  Zend\\Filter\\Encrypt .",
            "title": "Simplified usage with OpenSSL"
        },
        {
            "location": "/standard-filters/#compressing-content",
            "text": "Based on the original value, the encrypted value can be a very large string. To\nreduce the value,  Zend\\Filter\\Encrypt  allows the usage of compression.  The  compression  option can either be set to the name of a compression adapter,\nor to an array which sets all required options for the compression adapter.  // Use basic compression adapter\n$filter1 = new Zend\\Filter\\Encrypt([\n   'adapter'     => 'openssl',\n   'private'     => '/path/to/mykey/private.pem',\n   'public'      => '/public/key/path/public.pem',\n   'package'     => true,\n   'compression' => 'bz2'\n]);\n\n// Compression adatper with options:\n$filter2 = new Zend\\Filter\\Encrypt([\n   'adapter'     => 'openssl',\n   'private'     => '/path/to/mykey/private.pem',\n   'public'      => '/public/key/path/public.pem',\n   'package'     => true,\n   'compression' => ['adapter' => 'zip', 'target' => '\\usr\\tmp\\tmp.zip']\n]);",
            "title": "Compressing Content"
        },
        {
            "location": "/standard-filters/#decrypt-using-the-same-settings",
            "text": "When you want to decrypt a value which is additionally compressed, then you\nneed to set the same compression settings for decryption as for encryption;\notherwise decryption will fail.",
            "title": "Decrypt using the same settings"
        },
        {
            "location": "/standard-filters/#decryption-with-openssl",
            "text": "Decryption with  OpenSSL  follows the same patterns as for encryption, with one\ndifference: you must have all data, including the envelope key, from the person\nwho encrypted the content.  As an example:  // Use openssl and provide a private key\n$filter = new Zend\\Filter\\Decrypt([\n   'adapter' => 'openssl',\n   'private' => '/path/to/mykey/private.pem'\n]);\n\n// Add the envelope key; you can also add this during instantiation.\n$filter->setEnvelopeKey('/key/from/encoder/envelope_key.pem');  If encyption used a passphrase, you'll need to provide that as well:  // Use openssl and provide a private key\n$filter = new Zend\\Filter\\Decrypt([\n   'adapter' => 'openssl',\n   'passphrase' => 'enter here the passphrase for the private key',\n   'private' => '/path/to/mykey/private.pem'\n]);\n\n// Add the envelope key; you can also add this during instantiation.\n$filter->setEnvelopeKey('/key/from/encoder/envelope_key.pem');  Finally, you can decode the content.  Our complete example for decrypting the previously encrypted content looks like\nthis:  // Use openssl and provide a private key\n$filter = new Zend\\Filter\\Decrypt([\n   'adapter' => 'openssl',\n   'passphrase' => 'enter here the passphrase for the private key',\n   'private' => '/path/to/mykey/private.pem'\n]);\n\n// Add the envelope key; you can also add this during instantiation.\n$filter->setEnvelopeKey('/key/from/encoder/envelope_key.pem');\n\n$decrypted = $filter->filter('encoded_text_normally_unreadable');\nprint $decrypted;",
            "title": "Decryption with OpenSSL"
        },
        {
            "location": "/standard-filters/#htmlentities",
            "text": "Returns the string  $value , converting characters to their corresponding HTML\nentity equivalents when possible.",
            "title": "HtmlEntities"
        },
        {
            "location": "/standard-filters/#supported-options_10",
            "text": "The following options are supported for  Zend\\Filter\\HtmlEntities :   quotestyle : Equivalent to the PHP  htmlentities()  native function parameter\n   quote_style .  This allows you to define what will be done with 'single' and\n  \"double\" quotes. The following constants are accepted:  ENT_COMPAT ,\n   ENT_QUOTES , and  ENT_NOQUOTES , with the default being  ENT_COMPAT .  charset : Equivalent to the PHP  htmlentities()  native function parameter\n   charset . This defines the character set to be used in filtering. Unlike the\n  PHP native function, the default is 'UTF-8'. See the  PHP htmlentities\n  manual  for a list of supported character sets.   This option can also be set via the  $options  parameter as a Traversable\n  object or array. The option key will be accepted as either  charset  or\n   encoding .\n-  doublequote : Equivalent to the PHP  htmlentities()  native function\n  parameter  double_encode . If set to  false , existing HTML entities will not\n  be encoded. The default is to convert everything ( true ).  This option must be set via the  $options  parameter or the\n   setDoubleEncode()  method.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_7",
            "text": "$filter = new Zend\\Filter\\HtmlEntities();\n\nprint $filter->filter('<');",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#quote-style",
            "text": "Zend\\Filter\\HtmlEntities  allows changing the quote style used. This can be useful when you want to\nleave double, single, or both types of quotes un-filtered.  $filter = new Zend\\Filter\\HtmlEntities(['quotestyle' => ENT_QUOTES]);\n\n$input = \"A 'single' and \" . '\"double\"';\nprint $filter->filter($input);  The above example returns  A &#039;single&#039; and &quot;double&quot; . Notice\nthat 'single' as well as \"double\" quotes are filtered.  $filter = new Zend\\Filter\\HtmlEntities(['quotestyle' => ENT_COMPAT]);\n\n$input = \"A 'single' and \" . '\"double\"';\nprint $filter->filter($input);  The above example returns  A 'single' and &quot;double&quot; . Notice that\n\"double\" quotes are filtered while 'single' quotes are not altered.  $filter = new Zend\\Filter\\HtmlEntities(['quotestyle' => ENT_NOQUOTES]);\n\n$input = \"A 'single' and \" . '\"double\"';\nprint $filter->filter($input);  The above example returns  A 'single' and \"double\" . Notice that neither\n\"double\" or 'single' quotes are altered.",
            "title": "Quote Style"
        },
        {
            "location": "/standard-filters/#helper-methods",
            "text": "To change or retrieve the  quotestyle  after instantiation, the two methods setQuoteStyle()  and  getQuoteStyle()  may be used respectively. setQuoteStyle()  accepts one parameter,  $quoteStyle , which accepts one of the\nconstants  ENT_COMPAT ,  ENT_QUOTES , or  ENT_NOQUOTES .  $filter = new Zend\\Filter\\HtmlEntities();\n\n$filter->setQuoteStyle(ENT_QUOTES);\nprint $filter->getQuoteStyle(ENT_QUOTES);  To change or retrieve the  charset  after instantiation, the two methods setCharSet()  and  getCharSet()  may be used respectively.  setCharSet() \naccepts one parameter,  $charSet . See the  PHP htmlentities manual\npage  for a list of supported character sets.  $filter = new Zend\\Filter\\HtmlEntities();\n\n$filter->setQuoteStyle(ENT_QUOTES);\nprint $filter->getQuoteStyle(ENT_QUOTES);  To change or retrieve the  doublequote  option after instantiation, the two methods setDoubleQuote()  and  getDoubleQuote()  may be used respectively.  setDoubleQuote()  accepts one\nboolean parameter,  $doubleQuote .  $filter = new Zend\\Filter\\HtmlEntities();\n\n$filter->setQuoteStyle(ENT_QUOTES);\nprint $filter->getQuoteStyle(ENT_QUOTES);",
            "title": "Helper Methods"
        },
        {
            "location": "/standard-filters/#tofloat",
            "text": "Since 2.9.0   Zend\\Filter\\ToFloat  allows you to transform a scalar value into a float.",
            "title": "ToFloat"
        },
        {
            "location": "/standard-filters/#supported-options_11",
            "text": "There are no additional options for  Zend\\Filter\\ToFloat .",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_8",
            "text": "$filter = new Zend\\Filter\\ToFloat();\n\nprint $filter->filter('-4.4');  This will return  -4.4  (as a float).",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#toint",
            "text": "Zend\\Filter\\ToInt  allows you to transform a scalar value into an integer.",
            "title": "ToInt"
        },
        {
            "location": "/standard-filters/#supported-options_12",
            "text": "There are no additional options for  Zend\\Filter\\ToInt .",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_9",
            "text": "$filter = new Zend\\Filter\\ToInt();\n\nprint $filter->filter('-4 is less than 0');  This will return '-4'.",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#migration-from-20-23-to-24",
            "text": "Version 2.4 adds support for PHP 7. In PHP 7,  int  is a reserved keyword, which required renaming\nthe  Int  filter. If you were using the  Int  filter directly previously, you will now receive an E_USER_DEPRECATED  notice on instantiation. Please update your code to refer to the  ToInt  class\ninstead.  Users pulling their  Int  filter instance from the filter plugin manager receive a  ToInt  instance\ninstead starting in 2.4.0.",
            "title": "Migration from 2.0-2.3 to 2.4+"
        },
        {
            "location": "/standard-filters/#tonull",
            "text": "This filter will change the given input to be  NULL  if it meets specific\ncriteria. This is often necessary when you work with databases and want to have\na  NULL  value instead of a boolean or any other type.",
            "title": "ToNull"
        },
        {
            "location": "/standard-filters/#supported-options_13",
            "text": "The following options are supported for  Zend\\Filter\\ToNull :   type : The variable type which should be supported.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#default-behavior_1",
            "text": "Per default this filter works like PHP's  empty()  method; in other words, if empty()  returns a boolean  TRUE , then a  NULL  value will be returned.  $filter = new Zend\\Filter\\ToNull();\n$value  = '';\n$result = $filter->filter($value);\n// returns null instead of the empty string  This means that without providing any configuration,  Zend\\Filter\\ToNull  will\naccept all input types and return  NULL  in the same cases as  empty() .  Any other value will be returned as is, without any changes.",
            "title": "Default Behavior"
        },
        {
            "location": "/standard-filters/#changing-the-default-behavior_1",
            "text": "Sometimes it's not enough to filter based on  empty() . Therefore Zend\\Filter\\ToNull  allows you to configure which types will be converted, and\nwhich not.  The following types can be handled:   boolean : Converts a boolean  FALSE  value to  NULL .  integer : Converts an integer  0  value to  NULL .  empty_array : Converts an empty  array  to  NULL .  float : Converts an float  0.0  value to  NULL .  string : Converts an empty string  ''  to  NULL .  zero : Converts a string containing the single character zero ( '0' ) to  NULL .  all : Converts all above types to  NULL . (This is the default behavior.)   There are several ways to select which of the above types are filtered. You can\ngive one or multiple types and add them, you can give an array, you can use\nconstants, or you can give a textual string.  See the following examples:  // converts false to null\n$filter = new Zend\\Filter\\ToNull(Zend\\Filter\\ToNull::BOOLEAN);\n\n// converts false and 0 to null\n$filter = new Zend\\Filter\\ToNull(\n    Zend\\Filter\\ToNull::BOOLEAN + Zend\\Filter\\ToNull::INTEGER\n);\n\n// converts false and 0 to null\n$filter = new Zend\\Filter\\ToNull([\n    Zend\\Filter\\ToNull::BOOLEAN,\n    Zend\\Filter\\ToNull::INTEGER\n]);\n\n// converts false and 0 to null\n$filter = new Zend\\Filter\\ToNull([\n    'boolean',\n    'integer',\n]);  You can also give a  Traversable  or an array to set the wished types. To set\ntypes afterwards use  setType() .",
            "title": "Changing the Default Behavior"
        },
        {
            "location": "/standard-filters/#migration-from-20-23-to-24_1",
            "text": "Version 2.4 adds support for PHP 7. In PHP 7,  null  is a reserved keyword, which required renaming\nthe  Null  filter. If you were using the  Null  filter directly previously, you will now receive an E_USER_DEPRECATED  notice on instantiation. Please update your code to refer to the  ToNull  class\ninstead.  Users pulling their  Null  filter instance from the filter plugin manager receive a  ToNull \ninstance instead starting in 2.4.0.",
            "title": "Migration from 2.0-2.3 to 2.4+"
        },
        {
            "location": "/standard-filters/#numberformat",
            "text": "The  NumberFormat  filter can be used to return locale-specific number and percentage strings. It\nextends the  NumberParse  filter, which acts as wrapper for the  NumberFormatter  class within the\nInternationalization extension (Intl).  This filter is part of the zend-i18n package; you will need to include that\npackage in your application to use it.",
            "title": "NumberFormat"
        },
        {
            "location": "/standard-filters/#supported-options_14",
            "text": "The following options are supported for  NumberFormat :  NumberFormat([ string $locale [, int $style [, int $type ]]])    $locale : (Optional) Locale in which the number would be formatted (locale\n  name, e.g.  en_US ). If unset, it will use the default locale\n  ( Locale::getDefault() ). Methods for getting/setting the locale are also\n  available:  getLocale()  and  setLocale() .    $style : (Optional) Style of the formatting, one of the\n   format style constants .\n  If unset, it will use  NumberFormatter::DEFAULT_STYLE  as the default style.\n  Methods for getting/setting the format style are also available:  getStyle() \n  and  setStyle() .    $type : (Optional) The  formatting type \n  to use. If unset, it will use  NumberFormatter::TYPE_DOUBLE  as the default\n  type. Methods for getting/setting the format type are also available:\n   getType()  and  setType() .",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_10",
            "text": "$filter = new \\Zend\\I18n\\Filter\\NumberFormat('de_DE');\necho $filter->filter(1234567.8912346);\n// Returns '1.234.567,891'\n\n$filter = new \\Zend\\I18n\\Filter\\NumberFormat('en_US', NumberFormatter::PERCENT);\necho $filter->filter(0.80);\n// Returns '80%'\n\n$filter = new \\Zend\\I18n\\Filter\\NumberFormat('fr_FR', NumberFormatter::SCIENTIFIC);\necho $filter->filter(0.00123456789);\n// Returns '1,23456789E-3'",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#numberparse",
            "text": "The  NumberParse  filter can be used to parse a number from a string. It acts as\na wrapper for the  NumberFormatter  class within the Internationalization\nextension (Intl).  This filter is part of the zend-i18n package; you will need to include that\npackage in your application to use it.",
            "title": "NumberParse"
        },
        {
            "location": "/standard-filters/#supported-options_15",
            "text": "The following options are supported for  NumberParse :  NumberParse([ string $locale [, int $style [, int $type ]]])    $locale : (Optional) Locale in which the number would be parsed (locale name,\n  e.g.  en_US ). If unset, it will use the default locale\n  ( Locale::getDefault() ). Methods for getting/setting the locale are also\n  available:  getLocale()  and  setLocale() .    $style : (Optional) Style of the parsing, one of the\n   format style constants .\n  If unset, it will use  NumberFormatter::DEFAULT_STYLE  as the default style.\n  Methods for getting/setting the parse style are also available:  getStyle() \n  and  setStyle() .    $type : (Optional) The  parsing type \n  to use. If unset, it will use  NumberFormatter::TYPE_DOUBLE  as the default\n  type. Methods for getting/setting the parse type are also available:\n   getType()  and  setType() .",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_11",
            "text": "$filter = new \\Zend\\I18n\\Filter\\NumberParse('de_DE');\necho $filter->filter('1.234.567,891');\n// Returns 1234567.8912346\n\n$filter = new \\Zend\\I18n\\Filter\\NumberParse('en_US', NumberFormatter::PERCENT);\necho $filter->filter('80%');\n// Returns 0.80\n\n$filter = new \\Zend\\I18n\\Filter\\NumberParse('fr_FR', NumberFormatter::SCIENTIFIC);\necho $filter->filter('1,23456789E-3');\n// Returns 0.00123456789",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#pregreplace",
            "text": "Zend\\Filter\\PregReplace  performs a search using regular expressions and replaces all found\nelements.",
            "title": "PregReplace"
        },
        {
            "location": "/standard-filters/#supported-options_16",
            "text": "The following options are supported for  Zend\\Filter\\PregReplace :   pattern : The pattern to search for.  replacement : The string which to use as a replacement for the matches; this\n  can optionally contain placeholders for matched groups in the search pattern.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_12",
            "text": "To use this filter properly, you must give both options listed above.  The  pattern  option has to be given to set the pattern to search for. It can be\na string for a single pattern, or an array of strings for multiple patterns.  The  replacement  option indicates the string to replace matches with, and can\ncontain placeholders for matched groups from the search  pattern . The value may\nbe a string replacement, or an array of string replacements.  $filter = new Zend\\Filter\\PregReplace([\n    'pattern'     => '/bob/',\n    'replacement' => 'john',\n]);\n$input  = 'Hi bob!';\n\n$filter->filter($input);\n// returns 'Hi john!'  You can also use  setPattern()  to set the pattern(s), and  setReplacement()  set\nthe replacement(s).  $filter = new Zend\\Filter\\PregReplace();\n$filter\n    ->setPattern(array('bob', 'Hi'))\n    ->setReplacement(array('john', 'Bye'));\n$input = 'Hi bob!';\n\n$filter->filter($input);\n// returns 'Bye john!'  For more complex usage, read the PCRE Pattern chapter of the PHP manual .",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#realpath",
            "text": "This filter will resolve given links and pathnames, and returns the canonicalized\nabsolute pathnames.",
            "title": "RealPath"
        },
        {
            "location": "/standard-filters/#supported-options_17",
            "text": "The following options are supported for  Zend\\Filter\\RealPath :   exists : This option defaults to  TRUE , which validates that the given path\n  really exists.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_13",
            "text": "For any given link or pathname, its absolute path will be returned. References\nto  /./ ,  /../  and extra  /  sequences in the input path will be stripped. The\nresulting path will not have any symbolic links,  /./ , or  /../  sequences.  Zend\\Filter\\RealPath  will return  FALSE  on failure, e.g. if the file does not exist. On BSD\nsystems  Zend\\Filter\\RealPath  doesn't fail if only the last path component doesn't exist, while\nother systems will return  FALSE .  $filter = new Zend\\Filter\\RealPath();\n$path = '/www/var/path/../../mypath';\n$filtered = $filter->filter($path);\n\n// returns '/www/mypath'",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#non-existing-paths",
            "text": "Sometimes it is useful to get paths to files that do n0t exist; e.g., when you\nwant to get the real path for a path you want to create. You can then either\nprovide a  FALSE   exists  value at initiation, or use  setExists()  to set it.  $filter = new Zend\\Filter\\RealPath(false);\n$path = '/www/var/path/../../non/existing/path';\n$filtered = $filter->filter($path);\n\n// returns '/www/non/existing/path'\n// even when file_exists or realpath would return false",
            "title": "Non-Existing Paths"
        },
        {
            "location": "/standard-filters/#stringprefix",
            "text": "Since 2.9.0   This filter will add the provided prefix to scalar values.",
            "title": "StringPrefix"
        },
        {
            "location": "/standard-filters/#supported-options_18",
            "text": "The following options are supported for  Zend\\Filter\\StringPrefix :   prefix : The string prefix to add to values.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_14",
            "text": "$filter = new Zend\\Filter\\StringPrefix([\n    'prefix' => 'PHP-',\n]);\n\necho $filter->filter('MidCentral');  The above results in the string  PHP-MidCentral .",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#stringsuffix",
            "text": "Since 2.9.0   This filter will add the provided suffix to scalar values.",
            "title": "StringSuffix"
        },
        {
            "location": "/standard-filters/#supported-options_19",
            "text": "The following options are supported for  Zend\\Filter\\StringSuffix :   suffix : The string suffix to append to values.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_15",
            "text": "$filter = new Zend\\Filter\\StringSuffix([\n    'suffix' => '-PHP',\n]);\n\necho $filter->filter('MidCentral');  The above results in the string  MidCentral-PHP .",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#stringtolower",
            "text": "This filter converts any input to lowercase.",
            "title": "StringToLower"
        },
        {
            "location": "/standard-filters/#supported-options_20",
            "text": "The following options are supported for  Zend\\Filter\\StringToLower :   encoding : This option can be used to set an encoding to use.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_16",
            "text": "$filter = new Zend\\Filter\\StringToLower();\n\nprint $filter->filter('SAMPLE');\n// returns \"sample\"",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#handling-alternate-encoding",
            "text": "By default,  StringToLower  will only handle characters from the locale of your\nserver; characters from other charsets will be ignored. If you have the mbstring\nextension, however, you can use the filter with other encodings.  Pass the\ndesired encoding when initiating the  StringToLower  filter, or use the setEncoding()  method to change it.  // using UTF-8\n$filter = new Zend\\Filter\\StringToLower('UTF-8');\n\n// or give an array which can be useful when using a configuration\n$filter = new Zend\\Filter\\StringToLower(['encoding' => 'UTF-8']);\n\n// or do this afterwards\n$filter->setEncoding('ISO-8859-1');",
            "title": "Handling alternate encoding"
        },
        {
            "location": "/standard-filters/#setting-invalid-encodings",
            "text": "Be aware that you will get an exception when:   you attempt to set an encoding and the mbstring extension is unavailable; or  you attempt to set an encoding unsupported by the mbstring extension.",
            "title": "Setting invalid encodings"
        },
        {
            "location": "/standard-filters/#stringtoupper",
            "text": "This filter converts any input to UPPERCASE.",
            "title": "StringToUpper"
        },
        {
            "location": "/standard-filters/#supported-options_21",
            "text": "The following options are supported for  Zend\\Filter\\StringToUpper :   encoding : This option can be used to set the encoding to use.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_17",
            "text": "$filter = new Zend\\Filter\\StringToUpper();\n\nprint $filter->filter('Sample');\n// returns \"SAMPLE\"",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#different-encoded-strings",
            "text": "Like the  StringToLower  filter, this filter will only handle characters\nsupported by your server locale, unless you have the mbstring extension enabled.\nUsing different character sets works the same as with  StringToLower .  $filter = new Zend\\Filter\\StringToUpper(['encoding' => 'UTF-8']);\n\n// or do this afterwards\n$filter->setEncoding('ISO-8859-1');",
            "title": "Different Encoded Strings"
        },
        {
            "location": "/standard-filters/#stringtrim",
            "text": "This filter modifies a given string such that certain characters are removed\nfrom the beginning and end.",
            "title": "StringTrim"
        },
        {
            "location": "/standard-filters/#supported-options_22",
            "text": "The following options are supported for  Zend\\Filter\\StringTrim :   charlist : List of characters to remove from the beginning and end of the\n  string. If this is not set or is null, the default behavior will be invoked,\n  which is to remove only whitespace from the beginning and end of the string.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_18",
            "text": "$filter = new Zend\\Filter\\StringTrim();\n\nprint $filter->filter(' This is (my) content: ');  The above example returns  This is (my) content: . Notice that the whitespace\ncharacters have been removed.",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#specifying-alternate-characters",
            "text": "$filter = new Zend\\Filter\\StringTrim(':');\n// or new Zend\\Filter\\StringTrim(array('charlist' => ':'));\n\nprint $filter->filter(' This is (my) content:');  The above example returns  This is (my) content . Notice that the whitespace\ncharacters and colon are removed. You can also provide a  Traversable  or an\narray with a  charlist  key. To set the desired character list after\ninstantiation, use the  setCharList()  method.  getCharList()  returns the\ncurrent character list.",
            "title": "Specifying alternate characters"
        },
        {
            "location": "/standard-filters/#stripnewlines",
            "text": "This filter modifies a given string and removes all new line characters within\nthat string.",
            "title": "StripNewlines"
        },
        {
            "location": "/standard-filters/#supported-options_23",
            "text": "There are no additional options for  Zend\\Filter\\StripNewlines :",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_19",
            "text": "$filter = new Zend\\Filter\\StripNewlines();\n\nprint $filter->filter(' This is (my)``\\n\\r``content: ');  The above example returns  This is (my) content: . Notice that all newline\ncharacters have been removed.",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#striptags",
            "text": "This filter can strip XML and HTML tags from given content.",
            "title": "StripTags"
        },
        {
            "location": "/standard-filters/#zend92filter92striptags-is-potentially-insecure",
            "text": "Be warned that  Zend\\\\Filter\\\\StripTags  should only be used to strip  all \navailable tags.  Using  Zend\\\\Filter\\\\StripTags  to make your site secure by\nstripping  some  unwanted tags will lead to unsecure and dangerous code,\nincluding potential XSS vectors.  For a fully secure solution that allows selected filtering of HTML tags, use\neither Tidy or HtmlPurifier.",
            "title": "Zend\\Filter\\StripTags is potentially insecure"
        },
        {
            "location": "/standard-filters/#supported-options_24",
            "text": "The following options are supported for  Zend\\Filter\\StripTags :   allowAttribs : This option sets the attributes which are accepted. All other\n  attributes are stripped from the given content.  allowTags : This option sets the tags which are accepted. All other tags will\n  be stripped from; the given content.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_20",
            "text": "$filter = new Zend\\Filter\\StripTags();\n\nprint $filter->filter('<B>My content</B>');  The result will be the stripped content  My content .  When the content contains broken or partial tags, any content following the\nopening tag will be completely removed:  $filter = new Zend\\Filter\\StripTags();\n\nprint $filter->filter('This contains <a href=\"http://example.com\">no ending tag');  The above will return  This contains , with the rest being stripped.",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#allowing-defined-tags",
            "text": "Zend\\Filter\\StripTags  allows stripping all but a whitelist of tags. As an\nexample, this can be used to strip all markup except for links:  $filter = new Zend\\Filter\\StripTags(['allowTags' => 'a']);\n\n$input  = \"A text with <br/> a <a href='link.com'>link</a>\";\nprint $filter->filter($input);  The above will return  A text with a <a href='link.com'>link</a> ;\nit strips all tags but the link. By providing an array, you can specify multiple\ntags at once.",
            "title": "Allowing Defined Tags"
        },
        {
            "location": "/standard-filters/#warning",
            "text": "Do not use this feature to secure content. This component does not replace the\nuse of a properly configured html filter.",
            "title": "Warning"
        },
        {
            "location": "/standard-filters/#allowing-defined-attributes",
            "text": "You can also strip all but a whitelist of attributes from a tag:  $filter = new Zend\\Filter\\StripTags([\n    'allowTags' => 'img',\n    'allowAttribs' => 'src',\n]);\n\n$input  = \"A text with <br/> a <img src='picture.com' width='100'>picture</img>\";\nprint $filter->filter($input);  The above will return  A text with a <img src='picture.com'>picture</img> ; it\nstrips all tags but  <img> , and all attributes but  src  from those tags.By\nproviding an array you can set multiple attributes at once.",
            "title": "Allowing Defined Attributes"
        },
        {
            "location": "/standard-filters/#allow-specific-tags-with-specific-attributes",
            "text": "You can also pass the tag whitelist as a set of tag/attribute values. Each key\nwill be an allowed tag, pointing to a list of whitelisted attributes for that\ntag.  $allowedElements = [\n    'img' => [\n        'src',\n        'width'\n    ],\n    'a' => [\n        'href'\n    ]\n];\n$filter = new Zend\\Filter\\StripTags($allowedElements);\n\n$input = \"A text with <br/> a <img src='picture.com' width='100'>picture</img> click \"\n    . \"<a href='http://picture.com/zend' id='hereId'>here</a>!\";\nprint $filter->filter($input);  The above will return  A text with a <img src='picture.com'\nwidth='100'>picture</img> click <a href='<http://picture.com/zend>'>here</a>! \nas the result.",
            "title": "Allow specific tags with specific attributes"
        },
        {
            "location": "/standard-filters/#urinormalize",
            "text": "This filter sets the scheme on a URI if the scheme is missing.",
            "title": "UriNormalize"
        },
        {
            "location": "/standard-filters/#supported-options_25",
            "text": "The following options are supported for  Zend\\Filter\\UriNormalize :   defaultScheme : This option can be used to set the default scheme to use when\n  parsing scheme-less URIs.  enforcedScheme : Set a URI scheme to enforce on schemeless URIs.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_21",
            "text": "$filter = new Zend\\Filter\\UriNormalize(array(\n    'enforcedScheme' => 'https'\n));\n\necho $filter->filter('www.example.com');  The above results in the string  https://www.example.com .",
            "title": "Basic Usage"
        },
        {
            "location": "/standard-filters/#whitelist",
            "text": "This filter will return  null  if the value being filtered is not present the\nfilter's allowed list of values. If the value is present, it will return that\nvalue.  For the opposite functionality see the  Blacklist  filter.",
            "title": "Whitelist"
        },
        {
            "location": "/standard-filters/#supported-options_26",
            "text": "The following options are supported for  Zend\\Filter\\Whitelist :   strict : Uses strict mode for comparisons; passed to  in_array() 's third argument.  list : An array of allowed values.",
            "title": "Supported Options"
        },
        {
            "location": "/standard-filters/#basic-usage_22",
            "text": "$whitelist = new \\Zend\\Filter\\Whitelist([\n    'list' => ['allowed-1', 'allowed-2']\n]);\necho $whitelist->filter('allowed-2');   // => 'allowed-2'\necho $whitelist->filter('not-allowed'); // => null",
            "title": "Basic Usage"
        },
        {
            "location": "/word/",
            "text": "Word Filters\n\n\nIn addition to the standard set of filters, there are several classes specific\nto filtering word strings.\n\n\nCamelCaseToDash\n\n\nThis filter modifies a given string such that \nCamelCaseWords\n are converted to \nCamel-Case-Words\n.\n\n\nSupported Options\n\n\nThere are no additional options for \nZend\\Filter\\Word\\CamelCaseToDash\n:\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\Word\\CamelCaseToDash();\n\nprint $filter->filter('ThisIsMyContent');\n\n\n\nThe above example returns \nThis-Is-My-Content\n.\n\n\nCamelCaseToSeparator\n\n\nThis filter modifies a given string such that \nCamelCaseWords\n are converted to \nCamel Case Words\n.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\Word\\CamelCaseToSeparator\n:\n\n\n\n\nseparator\n: A separator character. If this is not set, the default separator\n  is a space.\n\n\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\Word\\CamelCaseToSeparator(':');\n// or new Zend\\Filter\\Word\\CamelCaseToSeparator(array('separator' => ':'));\n\nprint $filter->filter('ThisIsMyContent');\n\n\n\nThe above example returns \nThis:Is:My:Content\n.\n\n\nDefault Behavior\n\n\n$filter = new Zend\\Filter\\Word\\CamelCaseToSeparator();\n\nprint $filter->filter('ThisIsMyContent');\n\n\n\nThe above example returns \nThis Is My Content\n.\n\n\nCamelCaseToUnderscore\n\n\nThis filter modifies a given string such that \nCamelCaseWords\n are converted to\n\nCamel_Case_Words\n.\n\n\nSupported Options\n\n\nThere are no additional options for \nZend\\Filter\\Word\\CamelCaseToUnderscore\n:\n\n\nBasic usage\n\n\n$filter = new Zend\\Filter\\Word\\CamelCaseToUnderscore();\n\nprint $filter->filter('ThisIsMyContent');\n\n\n\nThe above example returns \nThis_Is_My_Content\n.\n\n\nDashToCamelCase\n\n\nThis filter modifies a given string such that \nwords-with-dashes\n are converted\nto \nWordsWithDashes\n.\n\n\nSupported Options\n\n\nThere are no additional options for \nZend\\Filter\\Word\\DashToCamelCase\n:\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\Word\\DashToCamelCase();\n\nprint $filter->filter('this-is-my-content');\n\n\n\nThe above example returns \nThisIsMyContent\n.\n\n\nDashToSeparator\n\n\nThis filter modifies a given string such that \nwords-with-dashes\n are converted\nto \nwords with dashes\n.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\Word\\DashToSeparator\n:\n\n\n\n\nseparator\n: A separator character. If this is not set, the default separator\n  is a space.\n\n\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\Word\\DashToSeparator('+');\n// or new Zend\\Filter\\Word\\CamelCaseToSeparator(array('separator' => '+'));\n\nprint $filter->filter('this-is-my-content');\n\n\n\nThe above example returns \nthis+is+my+content\n.\n\n\nDefault Behavior\n\n\n$filter = new Zend\\Filter\\Word\\DashToSeparator();\n\nprint $filter->filter('this-is-my-content');\n\n\n\nThe above example returns \nthis is my content\n.\n\n\nDashToUnderscore\n\n\nThis filter modifies a given string such that \nwords-with-dashes\n are converted\nto \nwords_with_dashes\n.\n\n\nSupported Options\n\n\nThere are no additional options for \nZend\\Filter\\Word\\DashToUnderscore\n:\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\Word\\DashToUnderscore();\n\nprint $filter->filter('this-is-my-content');\n\n\n\nThe above example returns \nthis_is_my_content\n.\n\n\nSeparatorToCamelCase\n\n\nThis filter modifies a given string such that \nwords with separators\n are\nconverted to \nWordsWithSeparators\n.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\Word\\SeparatorToCamelCase\n:\n\n\n\n\nseparator\n: A separator character. If this is not set, the default separator\n  is a space.\n\n\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\Word\\SeparatorToCamelCase(':');\n// or new Zend\\Filter\\Word\\SeparatorToCamelCase(array('separator' => ':'));\n\nprint $filter->filter('this:is:my:content');\n\n\n\nThe above example returns \nThisIsMyContent\n.\n\n\nDefault Behavior\n\n\n$filter = new Zend\\Filter\\Word\\SeparatorToCamelCase();\n\nprint $filter->filter('this is my content');\n\n\n\nThe above example returns \nThisIsMyContent\n.\n\n\nSeparatorToDash\n\n\nThis filter modifies a given string such that \nwords with separators\n are\nconverted to \nwords-with-separators\n.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\Word\\SeparatorToDash\n:\n\n\n\n\nseparator\n: A separator character. If this is not set, the default separator\n  is a space.\n\n\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\Word\\SeparatorToDash(':');\n// or new Zend\\Filter\\Word\\SeparatorToDash(array('separator' => ':'));\n\nprint $filter->filter('this:is:my:content');\n\n\n\nThe above example returns \nthis-is-my-content\n.\n\n\nDefault Behavior\n\n\n$filter = new Zend\\Filter\\Word\\SeparatorToDash();\n\nprint $filter->filter('this is my content');\n\n\n\nThe above example returns \nthis-is-my-content\n.\n\n\nSeparatorToSeparator\n\n\nThis filter modifies a given string such that \nwords with separators\n are\nconverted to \nwords-with-separators\n.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\Word\\SeparatorToSeparator\n:\n\n\n\n\nsearchSeparator\n: The search separator character. If this is not set, the\n  default separator is a space.\n\n\nreplaceSeparator\n: The replacement separator character. If this is not set, the\n  default separator is a dash (\n-\n).\n\n\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\Word\\SeparatorToSeparator(':', '+');\n\nprint $filter->filter('this:is:my:content');\n\n\n\nThe above example returns \nthis+is+my+content\n.\n\n\nDefault Behaviour\n\n\n$filter = new Zend\\Filter\\Word\\SeparatorToSeparator();\n\nprint $filter->filter('this is my content');\n\n\n\nThe above example returns \nthis-is-my-content\n.\n\n\nUnderscoreToCamelCase\n\n\nThis filter modifies a given string such that \nwords_with_underscores\n are\nconverted to \nWordsWithUnderscores\n.\n\n\nSupported Options\n\n\nThere are no additional options for \nZend\\Filter\\Word\\UnderscoreToCamelCase\n:\n\n\nBasic Usage\n\n\n$filter = new Zend\\Filter\\Word\\UnderscoreToCamelCase();\n\nprint $filter->filter('this_is_my_content');\n\n\n\nThe above example returns \nThisIsMyContent\n.\n\n\nUnderscoreToSeparator\n\n\nThis filter modifies a given string such that \nwords_with_underscores\n are\nconverted to \nwords with underscores\n.\n\n\nSupported Options\n\n\nThe following options are supported for \nZend\\Filter\\Word\\UnderscoreToSeparator\n:\n\n\n\n\nseparator\n: A separator character. If this is not set, the default separator\n  is a space.\n\n\n\n\nBasic usage\n\n\n$filter = new Zend\\Filter\\Word\\UnderscoreToSeparator('+');\n// or new Zend\\Filter\\Word\\CamelCaseToSeparator(array('separator' => '+'));\n\nprint $filter->filter('this_is_my_content');\n\n\n\nThe above example returns \nthis+is+my+content\n.\n\n\nDefault Behavior\n\n\n$filter = new Zend\\Filter\\Word\\UnderscoreToSeparator();\n\nprint $filter->filter('this_is_my_content');\n\n\n\nThe above example returns \nthis is my content\n.\n\n\nUnderscoreToDash\n\n\nThis filter modifies a given string such that \nwords_with_underscores\n are\nconverted to \nwords-with-underscores\n.\n\n\nSupported Options\n\n\nThere are no additional options for \nZend\\Filter\\Word\\UnderscoreToDash\n:\n\n\nBasic usage\n\n\n$filter = new Zend\\Filter\\Word\\UnderscoreToDash();\n\nprint $filter->filter('this_is_my_content');\n\n\n\nThe above example returns \nthis-is-my-content\n.",
            "title": "Word Filters"
        },
        {
            "location": "/word/#word-filters",
            "text": "In addition to the standard set of filters, there are several classes specific\nto filtering word strings.",
            "title": "Word Filters"
        },
        {
            "location": "/word/#camelcasetodash",
            "text": "This filter modifies a given string such that  CamelCaseWords  are converted to  Camel-Case-Words .",
            "title": "CamelCaseToDash"
        },
        {
            "location": "/word/#supported-options",
            "text": "There are no additional options for  Zend\\Filter\\Word\\CamelCaseToDash :",
            "title": "Supported Options"
        },
        {
            "location": "/word/#basic-usage",
            "text": "$filter = new Zend\\Filter\\Word\\CamelCaseToDash();\n\nprint $filter->filter('ThisIsMyContent');  The above example returns  This-Is-My-Content .",
            "title": "Basic Usage"
        },
        {
            "location": "/word/#camelcasetoseparator",
            "text": "This filter modifies a given string such that  CamelCaseWords  are converted to  Camel Case Words .",
            "title": "CamelCaseToSeparator"
        },
        {
            "location": "/word/#supported-options_1",
            "text": "The following options are supported for  Zend\\Filter\\Word\\CamelCaseToSeparator :   separator : A separator character. If this is not set, the default separator\n  is a space.",
            "title": "Supported Options"
        },
        {
            "location": "/word/#basic-usage_1",
            "text": "$filter = new Zend\\Filter\\Word\\CamelCaseToSeparator(':');\n// or new Zend\\Filter\\Word\\CamelCaseToSeparator(array('separator' => ':'));\n\nprint $filter->filter('ThisIsMyContent');  The above example returns  This:Is:My:Content .",
            "title": "Basic Usage"
        },
        {
            "location": "/word/#default-behavior",
            "text": "$filter = new Zend\\Filter\\Word\\CamelCaseToSeparator();\n\nprint $filter->filter('ThisIsMyContent');  The above example returns  This Is My Content .",
            "title": "Default Behavior"
        },
        {
            "location": "/word/#camelcasetounderscore",
            "text": "This filter modifies a given string such that  CamelCaseWords  are converted to Camel_Case_Words .",
            "title": "CamelCaseToUnderscore"
        },
        {
            "location": "/word/#supported-options_2",
            "text": "There are no additional options for  Zend\\Filter\\Word\\CamelCaseToUnderscore :",
            "title": "Supported Options"
        },
        {
            "location": "/word/#basic-usage_2",
            "text": "$filter = new Zend\\Filter\\Word\\CamelCaseToUnderscore();\n\nprint $filter->filter('ThisIsMyContent');  The above example returns  This_Is_My_Content .",
            "title": "Basic usage"
        },
        {
            "location": "/word/#dashtocamelcase",
            "text": "This filter modifies a given string such that  words-with-dashes  are converted\nto  WordsWithDashes .",
            "title": "DashToCamelCase"
        },
        {
            "location": "/word/#supported-options_3",
            "text": "There are no additional options for  Zend\\Filter\\Word\\DashToCamelCase :",
            "title": "Supported Options"
        },
        {
            "location": "/word/#basic-usage_3",
            "text": "$filter = new Zend\\Filter\\Word\\DashToCamelCase();\n\nprint $filter->filter('this-is-my-content');  The above example returns  ThisIsMyContent .",
            "title": "Basic Usage"
        },
        {
            "location": "/word/#dashtoseparator",
            "text": "This filter modifies a given string such that  words-with-dashes  are converted\nto  words with dashes .",
            "title": "DashToSeparator"
        },
        {
            "location": "/word/#supported-options_4",
            "text": "The following options are supported for  Zend\\Filter\\Word\\DashToSeparator :   separator : A separator character. If this is not set, the default separator\n  is a space.",
            "title": "Supported Options"
        },
        {
            "location": "/word/#basic-usage_4",
            "text": "$filter = new Zend\\Filter\\Word\\DashToSeparator('+');\n// or new Zend\\Filter\\Word\\CamelCaseToSeparator(array('separator' => '+'));\n\nprint $filter->filter('this-is-my-content');  The above example returns  this+is+my+content .",
            "title": "Basic Usage"
        },
        {
            "location": "/word/#default-behavior_1",
            "text": "$filter = new Zend\\Filter\\Word\\DashToSeparator();\n\nprint $filter->filter('this-is-my-content');  The above example returns  this is my content .",
            "title": "Default Behavior"
        },
        {
            "location": "/word/#dashtounderscore",
            "text": "This filter modifies a given string such that  words-with-dashes  are converted\nto  words_with_dashes .",
            "title": "DashToUnderscore"
        },
        {
            "location": "/word/#supported-options_5",
            "text": "There are no additional options for  Zend\\Filter\\Word\\DashToUnderscore :",
            "title": "Supported Options"
        },
        {
            "location": "/word/#basic-usage_5",
            "text": "$filter = new Zend\\Filter\\Word\\DashToUnderscore();\n\nprint $filter->filter('this-is-my-content');  The above example returns  this_is_my_content .",
            "title": "Basic Usage"
        },
        {
            "location": "/word/#separatortocamelcase",
            "text": "This filter modifies a given string such that  words with separators  are\nconverted to  WordsWithSeparators .",
            "title": "SeparatorToCamelCase"
        },
        {
            "location": "/word/#supported-options_6",
            "text": "The following options are supported for  Zend\\Filter\\Word\\SeparatorToCamelCase :   separator : A separator character. If this is not set, the default separator\n  is a space.",
            "title": "Supported Options"
        },
        {
            "location": "/word/#basic-usage_6",
            "text": "$filter = new Zend\\Filter\\Word\\SeparatorToCamelCase(':');\n// or new Zend\\Filter\\Word\\SeparatorToCamelCase(array('separator' => ':'));\n\nprint $filter->filter('this:is:my:content');  The above example returns  ThisIsMyContent .",
            "title": "Basic Usage"
        },
        {
            "location": "/word/#default-behavior_2",
            "text": "$filter = new Zend\\Filter\\Word\\SeparatorToCamelCase();\n\nprint $filter->filter('this is my content');  The above example returns  ThisIsMyContent .",
            "title": "Default Behavior"
        },
        {
            "location": "/word/#separatortodash",
            "text": "This filter modifies a given string such that  words with separators  are\nconverted to  words-with-separators .",
            "title": "SeparatorToDash"
        },
        {
            "location": "/word/#supported-options_7",
            "text": "The following options are supported for  Zend\\Filter\\Word\\SeparatorToDash :   separator : A separator character. If this is not set, the default separator\n  is a space.",
            "title": "Supported Options"
        },
        {
            "location": "/word/#basic-usage_7",
            "text": "$filter = new Zend\\Filter\\Word\\SeparatorToDash(':');\n// or new Zend\\Filter\\Word\\SeparatorToDash(array('separator' => ':'));\n\nprint $filter->filter('this:is:my:content');  The above example returns  this-is-my-content .",
            "title": "Basic Usage"
        },
        {
            "location": "/word/#default-behavior_3",
            "text": "$filter = new Zend\\Filter\\Word\\SeparatorToDash();\n\nprint $filter->filter('this is my content');  The above example returns  this-is-my-content .",
            "title": "Default Behavior"
        },
        {
            "location": "/word/#separatortoseparator",
            "text": "This filter modifies a given string such that  words with separators  are\nconverted to  words-with-separators .",
            "title": "SeparatorToSeparator"
        },
        {
            "location": "/word/#supported-options_8",
            "text": "The following options are supported for  Zend\\Filter\\Word\\SeparatorToSeparator :   searchSeparator : The search separator character. If this is not set, the\n  default separator is a space.  replaceSeparator : The replacement separator character. If this is not set, the\n  default separator is a dash ( - ).",
            "title": "Supported Options"
        },
        {
            "location": "/word/#basic-usage_8",
            "text": "$filter = new Zend\\Filter\\Word\\SeparatorToSeparator(':', '+');\n\nprint $filter->filter('this:is:my:content');  The above example returns  this+is+my+content .",
            "title": "Basic Usage"
        },
        {
            "location": "/word/#default-behaviour",
            "text": "$filter = new Zend\\Filter\\Word\\SeparatorToSeparator();\n\nprint $filter->filter('this is my content');  The above example returns  this-is-my-content .",
            "title": "Default Behaviour"
        },
        {
            "location": "/word/#underscoretocamelcase",
            "text": "This filter modifies a given string such that  words_with_underscores  are\nconverted to  WordsWithUnderscores .",
            "title": "UnderscoreToCamelCase"
        },
        {
            "location": "/word/#supported-options_9",
            "text": "There are no additional options for  Zend\\Filter\\Word\\UnderscoreToCamelCase :",
            "title": "Supported Options"
        },
        {
            "location": "/word/#basic-usage_9",
            "text": "$filter = new Zend\\Filter\\Word\\UnderscoreToCamelCase();\n\nprint $filter->filter('this_is_my_content');  The above example returns  ThisIsMyContent .",
            "title": "Basic Usage"
        },
        {
            "location": "/word/#underscoretoseparator",
            "text": "This filter modifies a given string such that  words_with_underscores  are\nconverted to  words with underscores .",
            "title": "UnderscoreToSeparator"
        },
        {
            "location": "/word/#supported-options_10",
            "text": "The following options are supported for  Zend\\Filter\\Word\\UnderscoreToSeparator :   separator : A separator character. If this is not set, the default separator\n  is a space.",
            "title": "Supported Options"
        },
        {
            "location": "/word/#basic-usage_10",
            "text": "$filter = new Zend\\Filter\\Word\\UnderscoreToSeparator('+');\n// or new Zend\\Filter\\Word\\CamelCaseToSeparator(array('separator' => '+'));\n\nprint $filter->filter('this_is_my_content');  The above example returns  this+is+my+content .",
            "title": "Basic usage"
        },
        {
            "location": "/word/#default-behavior_4",
            "text": "$filter = new Zend\\Filter\\Word\\UnderscoreToSeparator();\n\nprint $filter->filter('this_is_my_content');  The above example returns  this is my content .",
            "title": "Default Behavior"
        },
        {
            "location": "/word/#underscoretodash",
            "text": "This filter modifies a given string such that  words_with_underscores  are\nconverted to  words-with-underscores .",
            "title": "UnderscoreToDash"
        },
        {
            "location": "/word/#supported-options_11",
            "text": "There are no additional options for  Zend\\Filter\\Word\\UnderscoreToDash :",
            "title": "Supported Options"
        },
        {
            "location": "/word/#basic-usage_11",
            "text": "$filter = new Zend\\Filter\\Word\\UnderscoreToDash();\n\nprint $filter->filter('this_is_my_content');  The above example returns  this-is-my-content .",
            "title": "Basic usage"
        },
        {
            "location": "/file/",
            "text": "File Filters\n\n\nzend-filter also comes with a set of classes for filtering file contents, and\nperforming file operations such as renaming.\n\n\n\n\n$_FILES\n\n\nAll file filter \nfilter()\n implementations support either a file path string\n\nor\n a \n$_FILES\n array as the supplied argument. When a \n$_FILES\n array is\npassed in, the \ntmp_name\n is used for the file path.\n\n\n\n\nEncrypt and Decrypt\n\n\nThese filters allow encrypting and decrypting file contents, and are derived\nfrom the \nZend\\Filter\\Encrypt\n and \nZend\\Filter\\Decrypt\n filters. Only file reading and\nwriting operations are performed by the filer; encryption and decryption operations\nare performed by the parent classes.\n\n\nUsage:\n\n\nuse Zend\\Filter\\File\\Encrypt as EncryptFileFilter;\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new EncryptFileFilter([\n    'adapter' => 'BlockCipher',\n    'key' => '--our-super-secret-key--',\n]);\n$filter->filter($files['my-upload']);\n\n\n\nIn the above example, we pass options to our constructor in order to configure\nthe filter. We could instead use use setter methods to inject these options:\n\n\nuse Zend\\Filter\\File\\Encrypt as EncryptFileFilter;\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new EncryptFileFilter();\n$filter->setAdapter('BlockCipher');\n$filter->setKey('--our-super-secret-key--');\n$filter->filter($files['my-upload']);\n\n\n\nCheck the \nEncrypt and Decrypt filter documentation\n\nfor more information about options and adapters.\n\n\nLowercase\n\n\nZend\\Filter\\File\\Lowercase\n can be used to convert all file contents to\nlowercase.\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\nencoding\n: Set the encoding to use during conversion.\n\n\n\n\nBasic Usage\n\n\nuse Zend\\Filter\\File\\LowerCase;\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new LowerCase();\n$filter->filter($files['my-upload']);\n\n\n\nThis example converts the contents of an uploaded file to lowercase.  After this\nprocess, you can use the \nRename\n or \nRenameUpload\n\nfilter to replace this file with your original file, or read directly from file.\nBut, don't forget, if you upload a file and send your \n$_FILES\n array to a\nfilter method, the \nLowerCase\n filter will only change the temporary file\n(\ntmp_name\n index of array), not the original file. Let's check following\nexample:\n\n\nuse Zend\\Filter\\File\\LowerCase;\nuse Zend\\Filter\\File\\Rename;\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$lowercaseFilter = new LowerCase();\n$file = $lowercaseFilter->filter($files['userfile']);\n$renameFilter = new Rename([\n    'target'    => '/tmp/newfile.txt',\n    'randomize' => true,\n]);\n$filename = $renameFilter->filter($file['tmp_name']);\n\n\n\nWith this example, the final, stored file on the server will have the lowercased\ncontent.\n\n\nIf you want to use a specific encoding when converting file content, you should\nspecify the encoding when instantiating the \nLowerCase\n filter, or use the\n\nsetEncoding\n method to change it.\n\n\nuse Zend\\Filter\\File\\LowerCase;\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new LowerCase();\n$filter->setEncoding('ISO-8859-1');\n$filter->filter($files['my-upload']);\n\n\n\nThe \nLowerCase\n filter extends from the \nStringToLower\n filter; read the\n\nStringToLower\n documentation\n\nfor more information about encoding and its exceptions.\n\n\nRename\n\n\nZend\\Filter\\File\\Rename\n can be used to rename a file and/or move a file to a new path.\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\ntarget\n (string; default: \n*\n): Target filename or directory; the new name\n  of the source file.\n\n\nsource\n (string; default: \n*\n): Source filename or directory which will be\n  renamed. Used to match the filtered file with an options set.\n\n\noverwrite\n (boolean; default: \nfalse\n): Shall existing files be overwritten?\n  If the file is unable to be moved into the target path, a\n  \nZend\\Filter\\Exception\\RuntimeException\n will be thrown.\n\n\nrandomize\n (boolean; default: \nfalse\n): Shall target files have a random\n  postfix attached? The random postfix will generated with \nuniqid('_')\n after\n  the file name and before the extension. For example, \nfile.txt\n might be\n  randomized to \nfile_4b3403665fea6.txt\n.\n\n\n\n\nAn array of option sets is also supported, where a single \nRename\n filter\ninstance can filter several files using different options. The options used for\nthe filtered file will be matched from the \nsource\n option in the options set.\n\n\nUsage Examples\n\n\nMove all filtered files to a different directory:\n\n\n// 'target' option is assumed if param is a string\n$filter = new \\Zend\\Filter\\File\\Rename('/tmp/');\necho $filter->filter('./myfile.txt');\n// File has been moved to '/tmp/myfile.txt'\n\n\n\nRename all filtered files to a new name:\n\n\n$filter = new \\Zend\\Filter\\File\\Rename('/tmp/newfile.txt');\necho $filter->filter('./myfile.txt');\n// File has been renamed to '/tmp/newfile.txt'\n\n\n\nMove to a new path, and randomize file names:\n\n\n$filter = new \\Zend\\Filter\\File\\Rename([\n    'target'    => '/tmp/newfile.txt',\n    'randomize' => true,\n]);\necho $filter->filter('./myfile.txt');\n// File has been renamed to '/tmp/newfile_4b3403665fea6.txt'\n\n\n\nConfigure different options for several possible source files:\n\n\n$filter = new \\Zend\\Filter\\File\\Rename([\n    [\n        'source'    => 'fileA.txt'\n        'target'    => '/dest1/newfileA.txt',\n        'overwrite' => true,\n    ],\n    [\n        'source'    => 'fileB.txt'\n        'target'    => '/dest2/newfileB.txt',\n        'randomize' => true,\n    ],\n]);\necho $filter->filter('fileA.txt');\n// File has been renamed to '/dest1/newfileA.txt'\necho $filter->filter('fileB.txt');\n// File has been renamed to '/dest2/newfileB_4b3403665fea6.txt'\n\n\n\nPublic Methods\n\n\nThe \nRename\n filter defines the following public methods in addition to \nfilter()\n:\nfollows:\n\n\n\n\ngetFile() : array\n: Returns the files to rename along with their new name and location.\n\n\nsetFile(string|array $options) : void\n: Sets the file options for renaming.\n  Removes any previously set file options.\n\n\naddFile(string|array $options) : void\n: Adds file options for renaming to\n  the current list of file options.\n\n\n\n\nRenameUpload\n\n\nZend\\Filter\\File\\RenameUpload\n can be used to rename or move an uploaded file to a new path.\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\ntarget\n (string; default: \n*\n): Target directory or full filename path.\n\n\noverwrite\n (boolean; default: \nfalse\n): Shall existing files be overwritten?\n  If the file is unable to be moved into the target path, a\n  \nZend\\Filter\\Exception\\RuntimeException\n will be thrown.\n\n\nrandomize\n (boolean; default: \nfalse\n): Shall target files have a random\n  postfix attached? The random postfix will generated with \nuniqid('_')\n after\n  the file name and before the extension. For example, \nfile.txt\n might be\n  randomized to \nfile_4b3403665fea6.txt\n.\n\n\nuse_upload_name\n (boolean; default: \nfalse\n): When true, this filter will\n  use \n$_FILES['name']\n as the target filename. Otherwise, the default \ntarget\n\n  rules and the \n$_FILES['tmp_name']\n will be used.\n\n\nuse_upload_extension\n (boolean; default: \nfalse\n): When true, the uploaded\n  file will maintains its original extension if not specified.  For example, if\n  the uploaded file is \nfile.txt\n and the target is \nmynewfile\n, the upload\n  will be renamed to \nmynewfile.txt\n.\n\n\nstream_factory\n (\nPsr\\Http\\Message\\StreamFactoryInterface\n; default: \nnull\n):\n  Required when passing a \nPSR-7 UploadedFileInterface\n\n  to the filter; used to create a new stream representing the renamed file.\n  (Since 2.9.0)\n\n\nupload_file_factory\n (\nPsr\\Http\\Message\\UploadedFileFactoryInterface\n; default:\n  \nnull\n): Required when passing a \nPSR-7 UploadedFileInterface\n\n  to the filter; used to create a new uploaded file representation of the\n  renamed file.  (Since 2.9.0)\n\n\n\n\n\n\nUsing the upload name is unsafe\n\n\nBe \nvery\n careful when using the \nuse_upload_name\n option. For instance,\nextremely bad things could happen if you were to allow uploaded \n.php\n files\n(or other CGI files) to be moved into the \nDocumentRoot\n.\n\n\nIt is generally a better idea to supply an internal filename to avoid\nsecurity risks.\n\n\n\n\nRenameUpload\n does not support an array of options like the\nRename\n filter.\nWhen filtering HTML5 file uploads with the \nmultiple\n attribute set, all files\nwill be filtered with the same option settings.\n\n\nUsage Examples\n\n\nMove all filtered files to a different directory:\n\n\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n// i.e. $files['my-upload']['name'] === 'myfile.txt'\n\n// 'target' option is assumed if param is a string\n$filter = new \\Zend\\Filter\\File\\RenameUpload('./data/uploads/');\necho $filter->filter($files['my-upload']);\n// File has been moved to './data/uploads/php5Wx0aJ'\n\n// ... or retain the uploaded file name\n$filter->setUseUploadName(true);\necho $filter->filter($files['my-upload']);\n// File has been moved to './data/uploads/myfile.txt'\n\n\n\nRename all filtered files to a new name:\n\n\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new \\Zend\\Filter\\File\\RenameUpload('./data/uploads/newfile.txt');\necho $filter->filter($files['my-upload']);\n// File has been renamed to './data/uploads/newfile.txt'\n\n\n\nMove to a new path and randomize file names:\n\n\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new \\Zend\\Filter\\File\\RenameUpload([\n    'target'    => './data/uploads/newfile.txt',\n    'randomize' => true,\n]);\necho $filter->filter($files['my-upload']);\n// File has been renamed to './data/uploads/newfile_4b3403665fea6.txt'\n\n\n\nHandle a PSR-7 uploaded file:\n\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\nuse Psr\\Http\\Message\\UploadedFileFactoryInterface;\nuse Psr\\Http\\Message\\UploadedFileInterface;\nuse Zend\\Filter\\File\\RenameUpload;\n\n$filter = new \\Zend\\Filter\\File\\RenameUpload([\n    'target'              => './data/uploads/',\n    'randomize'           => true,\n    // @var StreamFactoryInterface $streamFactory\n    'stream_factory'      => $streamFactory,\n    // @var UploadedFileFactoryInterface $uploadedFileFactory\n    'upload_file_factory' => $uploadedFileFactory,\n]);\n\n// @var ServerRequestInterface $request\nforeach ($request->getUploadedFiles() as $uploadedFile) {\n    // @var UploadedFileInterface $uploadedFile\n    // @var UploadedFileInterface $movedFile\n    $movedFile = $filter->filter($uploadedFile);\n    echo $movedFile->getClientFilename();\n    // File has been renamed to './data/uploads/newfile_4b3403665fea6.txt'\n}\n\n\n\n\n\nPSR-7 support\n\n\nPSR-7/PSR-17 support has only been available since 2.9.0, and requires a valid\n\npsr/http-factory-implementation\n\nin your application, as it relies on the stream and uploaded file factories in\norder to produce the final \nUploadedFileInterface\n artifact representing the\nfiltered file.\n\n\nPSR-17 itself requires PHP 7, so your application will need to be running on\nPHP 7 in order to use this feature.\n\n\nzendframework/zend-diactoros 2.0\n\nprovides a PSR-17 implementation, but requires PHP 7.1. If you are still on\nPHP 7.0, either upgrade, or find a compatible psr/http-factory-implementation.\n\n\n\n\nUppercase\n\n\nZend\\Filter\\File\\Uppercase\n can be used to convert all file contents to\nuppercase.\n\n\nSupported Options\n\n\nThe following set of options are supported:\n\n\n\n\nencoding\n: Set the encoding to use during conversion.\n\n\n\n\nBasic Usage\n\n\nuse Zend\\Filter\\File\\UpperCase;\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new UpperCase();\n$filter->filter($files['my-upload']);\n\n\n\nSee the documentation on the \nLowerCase\n filter, above, for more\ninformation.",
            "title": "File Filters"
        },
        {
            "location": "/file/#file-filters",
            "text": "zend-filter also comes with a set of classes for filtering file contents, and\nperforming file operations such as renaming.",
            "title": "File Filters"
        },
        {
            "location": "/file/#_files",
            "text": "All file filter  filter()  implementations support either a file path string or  a  $_FILES  array as the supplied argument. When a  $_FILES  array is\npassed in, the  tmp_name  is used for the file path.",
            "title": "$_FILES"
        },
        {
            "location": "/file/#encrypt-and-decrypt",
            "text": "These filters allow encrypting and decrypting file contents, and are derived\nfrom the  Zend\\Filter\\Encrypt  and  Zend\\Filter\\Decrypt  filters. Only file reading and\nwriting operations are performed by the filer; encryption and decryption operations\nare performed by the parent classes.  Usage:  use Zend\\Filter\\File\\Encrypt as EncryptFileFilter;\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new EncryptFileFilter([\n    'adapter' => 'BlockCipher',\n    'key' => '--our-super-secret-key--',\n]);\n$filter->filter($files['my-upload']);  In the above example, we pass options to our constructor in order to configure\nthe filter. We could instead use use setter methods to inject these options:  use Zend\\Filter\\File\\Encrypt as EncryptFileFilter;\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new EncryptFileFilter();\n$filter->setAdapter('BlockCipher');\n$filter->setKey('--our-super-secret-key--');\n$filter->filter($files['my-upload']);  Check the  Encrypt and Decrypt filter documentation \nfor more information about options and adapters.",
            "title": "Encrypt and Decrypt"
        },
        {
            "location": "/file/#lowercase",
            "text": "Zend\\Filter\\File\\Lowercase  can be used to convert all file contents to\nlowercase.",
            "title": "Lowercase"
        },
        {
            "location": "/file/#supported-options",
            "text": "The following set of options are supported:   encoding : Set the encoding to use during conversion.",
            "title": "Supported Options"
        },
        {
            "location": "/file/#basic-usage",
            "text": "use Zend\\Filter\\File\\LowerCase;\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new LowerCase();\n$filter->filter($files['my-upload']);  This example converts the contents of an uploaded file to lowercase.  After this\nprocess, you can use the  Rename  or  RenameUpload \nfilter to replace this file with your original file, or read directly from file.\nBut, don't forget, if you upload a file and send your  $_FILES  array to a\nfilter method, the  LowerCase  filter will only change the temporary file\n( tmp_name  index of array), not the original file. Let's check following\nexample:  use Zend\\Filter\\File\\LowerCase;\nuse Zend\\Filter\\File\\Rename;\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$lowercaseFilter = new LowerCase();\n$file = $lowercaseFilter->filter($files['userfile']);\n$renameFilter = new Rename([\n    'target'    => '/tmp/newfile.txt',\n    'randomize' => true,\n]);\n$filename = $renameFilter->filter($file['tmp_name']);  With this example, the final, stored file on the server will have the lowercased\ncontent.  If you want to use a specific encoding when converting file content, you should\nspecify the encoding when instantiating the  LowerCase  filter, or use the setEncoding  method to change it.  use Zend\\Filter\\File\\LowerCase;\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new LowerCase();\n$filter->setEncoding('ISO-8859-1');\n$filter->filter($files['my-upload']);  The  LowerCase  filter extends from the  StringToLower  filter; read the StringToLower  documentation \nfor more information about encoding and its exceptions.",
            "title": "Basic Usage"
        },
        {
            "location": "/file/#rename",
            "text": "Zend\\Filter\\File\\Rename  can be used to rename a file and/or move a file to a new path.",
            "title": "Rename"
        },
        {
            "location": "/file/#supported-options_1",
            "text": "The following set of options are supported:   target  (string; default:  * ): Target filename or directory; the new name\n  of the source file.  source  (string; default:  * ): Source filename or directory which will be\n  renamed. Used to match the filtered file with an options set.  overwrite  (boolean; default:  false ): Shall existing files be overwritten?\n  If the file is unable to be moved into the target path, a\n   Zend\\Filter\\Exception\\RuntimeException  will be thrown.  randomize  (boolean; default:  false ): Shall target files have a random\n  postfix attached? The random postfix will generated with  uniqid('_')  after\n  the file name and before the extension. For example,  file.txt  might be\n  randomized to  file_4b3403665fea6.txt .   An array of option sets is also supported, where a single  Rename  filter\ninstance can filter several files using different options. The options used for\nthe filtered file will be matched from the  source  option in the options set.",
            "title": "Supported Options"
        },
        {
            "location": "/file/#usage-examples",
            "text": "Move all filtered files to a different directory:  // 'target' option is assumed if param is a string\n$filter = new \\Zend\\Filter\\File\\Rename('/tmp/');\necho $filter->filter('./myfile.txt');\n// File has been moved to '/tmp/myfile.txt'  Rename all filtered files to a new name:  $filter = new \\Zend\\Filter\\File\\Rename('/tmp/newfile.txt');\necho $filter->filter('./myfile.txt');\n// File has been renamed to '/tmp/newfile.txt'  Move to a new path, and randomize file names:  $filter = new \\Zend\\Filter\\File\\Rename([\n    'target'    => '/tmp/newfile.txt',\n    'randomize' => true,\n]);\necho $filter->filter('./myfile.txt');\n// File has been renamed to '/tmp/newfile_4b3403665fea6.txt'  Configure different options for several possible source files:  $filter = new \\Zend\\Filter\\File\\Rename([\n    [\n        'source'    => 'fileA.txt'\n        'target'    => '/dest1/newfileA.txt',\n        'overwrite' => true,\n    ],\n    [\n        'source'    => 'fileB.txt'\n        'target'    => '/dest2/newfileB.txt',\n        'randomize' => true,\n    ],\n]);\necho $filter->filter('fileA.txt');\n// File has been renamed to '/dest1/newfileA.txt'\necho $filter->filter('fileB.txt');\n// File has been renamed to '/dest2/newfileB_4b3403665fea6.txt'",
            "title": "Usage Examples"
        },
        {
            "location": "/file/#public-methods",
            "text": "The  Rename  filter defines the following public methods in addition to  filter() :\nfollows:   getFile() : array : Returns the files to rename along with their new name and location.  setFile(string|array $options) : void : Sets the file options for renaming.\n  Removes any previously set file options.  addFile(string|array $options) : void : Adds file options for renaming to\n  the current list of file options.",
            "title": "Public Methods"
        },
        {
            "location": "/file/#renameupload",
            "text": "Zend\\Filter\\File\\RenameUpload  can be used to rename or move an uploaded file to a new path.",
            "title": "RenameUpload"
        },
        {
            "location": "/file/#supported-options_2",
            "text": "The following set of options are supported:   target  (string; default:  * ): Target directory or full filename path.  overwrite  (boolean; default:  false ): Shall existing files be overwritten?\n  If the file is unable to be moved into the target path, a\n   Zend\\Filter\\Exception\\RuntimeException  will be thrown.  randomize  (boolean; default:  false ): Shall target files have a random\n  postfix attached? The random postfix will generated with  uniqid('_')  after\n  the file name and before the extension. For example,  file.txt  might be\n  randomized to  file_4b3403665fea6.txt .  use_upload_name  (boolean; default:  false ): When true, this filter will\n  use  $_FILES['name']  as the target filename. Otherwise, the default  target \n  rules and the  $_FILES['tmp_name']  will be used.  use_upload_extension  (boolean; default:  false ): When true, the uploaded\n  file will maintains its original extension if not specified.  For example, if\n  the uploaded file is  file.txt  and the target is  mynewfile , the upload\n  will be renamed to  mynewfile.txt .  stream_factory  ( Psr\\Http\\Message\\StreamFactoryInterface ; default:  null ):\n  Required when passing a  PSR-7 UploadedFileInterface \n  to the filter; used to create a new stream representing the renamed file.\n  (Since 2.9.0)  upload_file_factory  ( Psr\\Http\\Message\\UploadedFileFactoryInterface ; default:\n   null ): Required when passing a  PSR-7 UploadedFileInterface \n  to the filter; used to create a new uploaded file representation of the\n  renamed file.  (Since 2.9.0)",
            "title": "Supported Options"
        },
        {
            "location": "/file/#using-the-upload-name-is-unsafe",
            "text": "Be  very  careful when using the  use_upload_name  option. For instance,\nextremely bad things could happen if you were to allow uploaded  .php  files\n(or other CGI files) to be moved into the  DocumentRoot .  It is generally a better idea to supply an internal filename to avoid\nsecurity risks.   RenameUpload  does not support an array of options like the Rename  filter.\nWhen filtering HTML5 file uploads with the  multiple  attribute set, all files\nwill be filtered with the same option settings.",
            "title": "Using the upload name is unsafe"
        },
        {
            "location": "/file/#usage-examples_1",
            "text": "Move all filtered files to a different directory:  use Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n// i.e. $files['my-upload']['name'] === 'myfile.txt'\n\n// 'target' option is assumed if param is a string\n$filter = new \\Zend\\Filter\\File\\RenameUpload('./data/uploads/');\necho $filter->filter($files['my-upload']);\n// File has been moved to './data/uploads/php5Wx0aJ'\n\n// ... or retain the uploaded file name\n$filter->setUseUploadName(true);\necho $filter->filter($files['my-upload']);\n// File has been moved to './data/uploads/myfile.txt'  Rename all filtered files to a new name:  use Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new \\Zend\\Filter\\File\\RenameUpload('./data/uploads/newfile.txt');\necho $filter->filter($files['my-upload']);\n// File has been renamed to './data/uploads/newfile.txt'  Move to a new path and randomize file names:  use Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new \\Zend\\Filter\\File\\RenameUpload([\n    'target'    => './data/uploads/newfile.txt',\n    'randomize' => true,\n]);\necho $filter->filter($files['my-upload']);\n// File has been renamed to './data/uploads/newfile_4b3403665fea6.txt'  Handle a PSR-7 uploaded file:  use Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\nuse Psr\\Http\\Message\\UploadedFileFactoryInterface;\nuse Psr\\Http\\Message\\UploadedFileInterface;\nuse Zend\\Filter\\File\\RenameUpload;\n\n$filter = new \\Zend\\Filter\\File\\RenameUpload([\n    'target'              => './data/uploads/',\n    'randomize'           => true,\n    // @var StreamFactoryInterface $streamFactory\n    'stream_factory'      => $streamFactory,\n    // @var UploadedFileFactoryInterface $uploadedFileFactory\n    'upload_file_factory' => $uploadedFileFactory,\n]);\n\n// @var ServerRequestInterface $request\nforeach ($request->getUploadedFiles() as $uploadedFile) {\n    // @var UploadedFileInterface $uploadedFile\n    // @var UploadedFileInterface $movedFile\n    $movedFile = $filter->filter($uploadedFile);\n    echo $movedFile->getClientFilename();\n    // File has been renamed to './data/uploads/newfile_4b3403665fea6.txt'\n}",
            "title": "Usage Examples"
        },
        {
            "location": "/file/#psr-7-support",
            "text": "PSR-7/PSR-17 support has only been available since 2.9.0, and requires a valid psr/http-factory-implementation \nin your application, as it relies on the stream and uploaded file factories in\norder to produce the final  UploadedFileInterface  artifact representing the\nfiltered file.  PSR-17 itself requires PHP 7, so your application will need to be running on\nPHP 7 in order to use this feature.  zendframework/zend-diactoros 2.0 \nprovides a PSR-17 implementation, but requires PHP 7.1. If you are still on\nPHP 7.0, either upgrade, or find a compatible psr/http-factory-implementation.",
            "title": "PSR-7 support"
        },
        {
            "location": "/file/#uppercase",
            "text": "Zend\\Filter\\File\\Uppercase  can be used to convert all file contents to\nuppercase.",
            "title": "Uppercase"
        },
        {
            "location": "/file/#supported-options_3",
            "text": "The following set of options are supported:   encoding : Set the encoding to use during conversion.",
            "title": "Supported Options"
        },
        {
            "location": "/file/#basic-usage_1",
            "text": "use Zend\\Filter\\File\\UpperCase;\nuse Zend\\Http\\PhpEnvironment\\Request;\n\n$request = new Request();\n$files   = $request->getFiles();\n// i.e. $files['my-upload']['tmp_name'] === '/tmp/php5Wx0aJ'\n\n$filter = new UpperCase();\n$filter->filter($files['my-upload']);  See the documentation on the  LowerCase  filter, above, for more\ninformation.",
            "title": "Basic Usage"
        },
        {
            "location": "/filter-chains/",
            "text": "Filter Chains\n\n\nOften, multiple filters should be applied to some value in a particular order.\nFor example, a login form accepts a username that should be lowercase and\ncontain only alphabetic characters.\n\n\nZend\\Filter\\FilterChain\n provides a simple method by which filters may be\nchained together. The following code illustrates how to chain together two\nfilters for the submitted username and fulfill the above requirements:\n\n\n// Create a filter chain and add filters to the chain\n$filterChain = new Zend\\Filter\\FilterChain();\n$filterChain\n    ->attach(new Zend\\I18n\\Filter\\Alpha())\n    ->attach(new Zend\\Filter\\StringToLower());\n\n// Filter the username\n$username = $filterChain->filter($_POST['username']);\n\n\n\nFilters are run in the order they are added to the filter chain. In the above\nexample, the username is first removed of any non-alphabetic characters, and\nthen any uppercase characters are converted to lowercase.\n\n\nAny object that implements \nZend\\Filter\\FilterInterface\n may be used in a\nfilter chain.\n\n\nSetting Filter Chain Order\n\n\nFor each filter added to the \nFilterChain\n, you can set a priority to define\nthe chain order. Higher values indicate higher priority (execute first), while\nlower and/or negative values indicate lower priority (execute last). The default value is \n1000\n.\n\n\nIn the following example, any uppercase characters are converted to lowercase\nbefore any non-alphabetic characters are removed.\n\n\n// Create a filter chain and add filters to the chain\n$filterChain = new Zend\\Filter\\FilterChain();\n$filterChain\n    ->attach(new Zend\\I18n\\Filter\\Alpha())\n    ->attach(new Zend\\Filter\\StringToLower(), 500);\n\n\n\nUsing the Plugin Manager\n\n\nA \nFilterPluginManager\n is attached to every \nFilterChain\n instance. Every filter\nthat is used in a \nFilterChain\n must be known to the \nFilterPluginManager\n.\n\n\nTo add a filter to the \nFilterChain\n, use the \nattachByName()\n method. The\nfirst parameter is the name of the filter within the \nFilterPluginManager\n. The\nsecond parameter takes any options for creating the filter instance. The third\nparameter is the priority.\n\n\n// Create a filter chain and add filters to the chain\n$filterChain = new Zend\\Filter\\FilterChain();\n$filterChain\n    ->attachByName('alpha')\n    ->attachByName('stringtolower', ['encoding' => 'utf-8'], 500);\n\n\n\nThe following example shows how to add a custom filter to the \nFilterPluginManager\n and the\n\nFilterChain\n:\n\n\n$filterChain = new Zend\\Filter\\FilterChain();\n$filterChain\n    ->getPluginManager()\n    ->setInvokableClass('myNewFilter', 'MyCustom\\Filter\\MyNewFilter');\n$filterChain\n    ->attachByName('alpha')\n    ->attachByName('myNewFilter');\n\n\n\nYou can also add your own \nFilterPluginManager\n implementation:\n\n\n$filterChain = new Zend\\Filter\\FilterChain();\n$filterChain->setPluginManager(new MyFilterPluginManager());\n$filterChain\n    ->attach(new Zend\\I18n\\Filter\\Alpha())\n    ->attach(new MyCustom\\Filter\\MyNewFilter());",
            "title": "Filter Chains"
        },
        {
            "location": "/filter-chains/#filter-chains",
            "text": "Often, multiple filters should be applied to some value in a particular order.\nFor example, a login form accepts a username that should be lowercase and\ncontain only alphabetic characters.  Zend\\Filter\\FilterChain  provides a simple method by which filters may be\nchained together. The following code illustrates how to chain together two\nfilters for the submitted username and fulfill the above requirements:  // Create a filter chain and add filters to the chain\n$filterChain = new Zend\\Filter\\FilterChain();\n$filterChain\n    ->attach(new Zend\\I18n\\Filter\\Alpha())\n    ->attach(new Zend\\Filter\\StringToLower());\n\n// Filter the username\n$username = $filterChain->filter($_POST['username']);  Filters are run in the order they are added to the filter chain. In the above\nexample, the username is first removed of any non-alphabetic characters, and\nthen any uppercase characters are converted to lowercase.  Any object that implements  Zend\\Filter\\FilterInterface  may be used in a\nfilter chain.",
            "title": "Filter Chains"
        },
        {
            "location": "/filter-chains/#setting-filter-chain-order",
            "text": "For each filter added to the  FilterChain , you can set a priority to define\nthe chain order. Higher values indicate higher priority (execute first), while\nlower and/or negative values indicate lower priority (execute last). The default value is  1000 .  In the following example, any uppercase characters are converted to lowercase\nbefore any non-alphabetic characters are removed.  // Create a filter chain and add filters to the chain\n$filterChain = new Zend\\Filter\\FilterChain();\n$filterChain\n    ->attach(new Zend\\I18n\\Filter\\Alpha())\n    ->attach(new Zend\\Filter\\StringToLower(), 500);",
            "title": "Setting Filter Chain Order"
        },
        {
            "location": "/filter-chains/#using-the-plugin-manager",
            "text": "A  FilterPluginManager  is attached to every  FilterChain  instance. Every filter\nthat is used in a  FilterChain  must be known to the  FilterPluginManager .  To add a filter to the  FilterChain , use the  attachByName()  method. The\nfirst parameter is the name of the filter within the  FilterPluginManager . The\nsecond parameter takes any options for creating the filter instance. The third\nparameter is the priority.  // Create a filter chain and add filters to the chain\n$filterChain = new Zend\\Filter\\FilterChain();\n$filterChain\n    ->attachByName('alpha')\n    ->attachByName('stringtolower', ['encoding' => 'utf-8'], 500);  The following example shows how to add a custom filter to the  FilterPluginManager  and the FilterChain :  $filterChain = new Zend\\Filter\\FilterChain();\n$filterChain\n    ->getPluginManager()\n    ->setInvokableClass('myNewFilter', 'MyCustom\\Filter\\MyNewFilter');\n$filterChain\n    ->attachByName('alpha')\n    ->attachByName('myNewFilter');  You can also add your own  FilterPluginManager  implementation:  $filterChain = new Zend\\Filter\\FilterChain();\n$filterChain->setPluginManager(new MyFilterPluginManager());\n$filterChain\n    ->attach(new Zend\\I18n\\Filter\\Alpha())\n    ->attach(new MyCustom\\Filter\\MyNewFilter());",
            "title": "Using the Plugin Manager"
        },
        {
            "location": "/inflector/",
            "text": "String Inflection\n\n\nZend\\Filter\\Inflector\n is a general purpose tool for rules-based inflection of\nstrings to a given target.\n\n\nAs an example, you may find you need to transform MixedCase or camelCasedWords\ninto a path; for readability, OS policies, or other reasons, you also need to\nlower case this; and finally, you want to separate the words using a dash\n(\n-\n). An inflector can do this for you.\n\n\nZend\\Filter\\Inflector\n implements \nZend\\Filter\\FilterInterface\n; you perform\ninflection by calling \nfilter()\n on the object instance.\n\n\nTransforming MixedCase and camelCaseText to another format\n\n\n$inflector = new Zend\\Filter\\Inflector('pages/:page.:suffix');\n$inflector->setRules([\n    ':page'  => ['Word\\CamelCaseToDash', 'StringToLower'],\n    'suffix' => 'html',\n]);\n\n$string   = 'camelCasedWords';\n$filtered = $inflector->filter(['page' => $string]);\n// pages/camel-cased-words.html\n\n$string   = 'this_is_not_camel_cased';\n$filtered = $inflector->filter(['page' => $string]);\n// pages/this_is_not_camel_cased.html\n\n\n\nOperation\n\n\nAn inflector requires a \ntarget\n and one or more \nrules\n. A target is\nbasically a string that defines placeholders for variables you wish to\nsubstitute. These are specified by prefixing with a \n:\n: \n:script\n.\n\n\nWhen calling \nfilter()\n, you then pass in an array of key and value pairs\ncorresponding to the variables in the target.\n\n\nEach variable in the target can have zero or more rules associated with them.\nRules may be either \nstatic\n or refer to a zend-filter class. Static rules\nwill replace with the text provided.  Otherwise, a class matching the rule\nprovided will be used to inflect the text. Classes are typically specified\nusing a short name indicating the filter name stripped of any common prefix.\n\n\nAs an example, you can use any zend-filter concrete implementations; however,\ninstead of referring to them as \nZend\\I18n\\Filter\\Alpha\n or\n\nZend\\Filter\\StringToLower\n, you'd specify only \nAlpha\n or \nStringToLower\n.\n\n\nUsing Custom Filters\n\n\nZend\\Filter\\Inflector\n uses \nZend\\Filter\\FilterPluginManager\n to manage\nloading filters to use with inflection. By default, filters registered with\n\nZend\\Filter\\FilterPluginManager\n are available. To access filters with that\nprefix but which occur deeper in the hierarchy, such as the various \nWord\n\nfilters, simply strip off the \nZend\\Filter\n prefix:\n\n\n// use Zend\\Filter\\Word\\CamelCaseToDash as a rule\n$inflector->addRules(['script' => 'Word\\CamelCaseToDash']);\n\n\n\nTo use custom filters, you have two choices: reference them by fully qualified\nclass name (e.g., \nMy\\Custom\\Filter\\Mungify\n), or manipulate the composed\n\nFilterPluginManager\n instance.\n\n\n$filters = $inflector->getPluginManager();\n$filters->addInvokableClass('mungify', 'My\\Custom\\Filter\\Mungify');\n\n\n\nSetting the Inflector Target\n\n\nThe inflector target is a string with some placeholders for variables.\nPlaceholders take the form of an identifier, a colon (\n:\n) by default, followed\nby a variable name: \n:script\n, \n:path\n, etc. The \nfilter()\n method looks for\nthe identifier followed by the variable name being replaced.\n\n\nYou can change the identifier using the \nsetTargetReplacementIdentifier()\n\nmethod, or passing it as the fourth argument to the constructor:\n\n\n// Via constructor:\n$inflector = new Zend\\Filter\\Inflector('#foo/#bar.#sfx', array(), null, '#');\n\n// Via accessor:\n$inflector->setTargetReplacementIdentifier('#');\n\n\n\nTypically, you will set the target via the constructor. However, you may want\nto re-set the target later. \nsetTarget()\n can be used for this purpose:\n\n\n$inflector->setTarget('layouts/:script.phtml');\n\n\n\nAdditionally, you may wish to have a class member for your class that you can\nuse to keep the inflector target updated \u2014 without needing to directly update\nthe target each time (thus saving on method calls). \nsetTargetReference()\n\nallows you to do this:\n\n\nclass Foo\n{\n    /**\n     * @var string Inflector target\n     */\n    protected $target = 'foo/:bar/:baz.:suffix';\n\n    /**\n     * Constructor\n     * @return void\n     */\n    public function __construct()\n    {\n        $this->inflector = new Zend\\Filter\\Inflector();\n        $this->inflector->setTargetReference($this->target);\n    }\n\n    /**\n     * Set target; updates target in inflector\n     *\n     * @param  string $target\n     * @return Foo\n     */\n    public function setTarget($target)\n    {\n        $this->target = $target;\n        return $this;\n    }\n}\n\n\n\nInflection Rules\n\n\nAs mentioned in the introduction, there are two types of rules: static and filter-based.\n\n\n\n\nOrder is important\n\n\nIt is important to note that regardless of the method in which you add rules\nto the inflector, either one-by-one, or all-at-once; the order is very\nimportant. More specific names, or names that might contain other rule names,\nmust be added before least specific names. For example, assuming the two rule\nnames \nmoduleDir\n and \nmodule\n, the \nmoduleDir\n rule should appear before\nmodule since \nmodule\n is contained within \nmoduleDir\n. If \nmodule\n were added\nbefore \nmoduleDir\n, \nmodule\n will match part of \nmoduleDir\n and process it\nleaving \nDir\n inside of the target uninflected.\n\n\n\n\nStatic Rules\n\n\nStatic rules do simple string substitution; use them when you have a segment in\nthe target that will typically be static, but which you want to allow the\ndeveloper to modify. Use the \nsetStaticRule()\n method to set or modify the\nrule:\n\n\n$inflector = new Zend\\Filter\\Inflector(':script.:suffix');\n$inflector->setStaticRule('suffix', 'phtml');\n\n// change it later:\n$inflector->setStaticRule('suffix', 'php');\n\n\n\nMuch like the target itself, you can also bind a static rule to a reference,\nallowing you to update a single variable instead of require a method call; this\nis often useful when your class uses an inflector internally, and you don't\nwant your users to need to fetch the inflector in order to update it. The\n\nsetStaticRuleReference()\n method is used to accomplish this:\n\n\nclass Foo\n{\n    /**\n     * @var string Suffix\n     */\n    private $suffix = 'phtml';\n\n    /**\n     * Constructor\n     * @return void\n     */\n    public function construct()\n    {\n        $this->inflector = new Zend\\Filter\\Inflector(':script.:suffix');\n        $this->inflector->setStaticRuleReference('suffix', $this->suffix);\n    }\n\n    /**\n     * Set suffix; updates suffix static rule in inflector\n     *\n     * @param  string $suffix\n     * @return Foo\n     */\n    public function setSuffix($suffix)\n    {\n        $this->suffix = $suffix;\n        return $this;\n    }\n}\n\n\n\nFilter-Based Inflector Rules\n\n\nZend\\Filter\n filters may be used as inflector rules as well. Just like static\nrules, these are bound to a target variable; unlike static rules, you may\ndefine multiple filters to use when inflecting. These filters are processed in\norder, so be careful to register them in an order that makes sense for the data\nyou receive.\n\n\nRules may be added using \nsetFilterRule()\n (which overwrites any previous rules\nfor that variable) or \naddFilterRule()\n (which appends the new rule to any\nexisting rule for that variable). Filters are specified in one of the following\nways:\n\n\n\n\nString\n. The string may be a filter class name, or a class name segment\n  minus any prefix set in the inflector's plugin loader (by default, minus the\n  '\nZend\\Filter\n' prefix).\n\n\nFilter object\n. Any object instance implementing\n  \nZend\\Filter\\FilterInterface\n may be passed as a filter.\n\n\nArray\n. An array of one or more strings or filter objects as defined above.\n\n\n\n\n$inflector = new Zend\\Filter\\Inflector(':script.:suffix');\n\n// Set rule to use Zend\\Filter\\Word\\CamelCaseToDash filter\n$inflector->setFilterRule('script', 'Word\\CamelCaseToDash');\n\n// Add rule to lowercase string\n$inflector->addFilterRule('script', new Zend\\Filter\\StringToLower());\n\n// Set rules en-masse\n$inflector->setFilterRule('script', [\n    'Word\\CamelCaseToDash',\n    new Zend\\Filter\\StringToLower()\n]);\n\n\n\nSetting Many Rules At Once\n\n\nTypically, it's easier to set many rules at once than to configure a single\nvariable and its inflection rules one at a time. \nZend\\Filter\\Inflector\n's\n\naddRules()\n and \nsetRules()\n methods allow this.\n\n\nEach method takes an array of variable and rule pairs, where the rule may be\nwhatever the type of rule accepts (string, filter object, or array). Variable\nnames accept a special notation to allow setting static rules and filter rules,\naccording to the following notation:\n\n\n\n\n:\n prefix\n: filter rules.\n\n\nNo prefix\n: static rule.\n\n\n\n\nAs an example:\n\n\n// Could also use setRules() with this notation:\n$inflector->addRules([\n    // Filter rules:\n    ':controller' => ['Word\\CamelCaseToUnderscore','StringToLower'],\n    ':action'     => ['Word\\CamelCaseToUnderscore','StringToLower'],\n\n    // Static rule:\n    'suffix'      => 'phtml',\n]);\n\n\n\nUtility Methods\n\n\nZend\\Filter\\Inflector\n has a number of utility methods for retrieving and\nsetting the plugin loader, manipulating and retrieving rules, and controlling\nif and when exceptions are thrown.\n\n\n\n\nsetPluginManager()\n can be used when you have configured your own\n  \nZend\\Filter\\FilterPluginManager\n instance and wish to use it with\n  \nZend\\Filter\\Inflector\n; \ngetPluginManager()\n retrieves the currently set\n  one.\n\n\nsetThrowTargetExceptionsOn()\n can be used to control whether or not\n  \nfilter()\n throws an exception when a given replacement identifier passed to\n  it is not found in the target. By default, no exceptions are thrown.\n  \nisThrowTargetExceptionsOn()\n will tell you what the current value is.\n\n\ngetRules($spec = null)\n can be used to retrieve all registered rules for all\n  variables, or just the rules for a single variable.\n\n\ngetRule($spec, $index)\n fetches a single rule for a given variable; this can\n  be useful for fetching a specific filter rule for a variable that has a\n  filter chain. \n$index\n must be passed.\n\n\nclearRules()\n will clear all currently registered rules.\n\n\n\n\nUsing a Traversable or an array\n\n\nYou can use a \nTraversable\n or an array to set rules and other object state in\nyour inflectors, by passing either type to either the constructor or the\n\nsetOptions()\n method. The following settings may be specified:\n\n\n\n\ntarget\n specifies the inflection target.\n\n\npluginManager\n specifies the \nZend\\Filter\\FilterPluginManager\n instance or\n  extension to use for obtaining plugins; alternately, you may specify a class\n  name of a class that extends the \nFilterPluginManager\n.\n\n\nthrowTargetExceptionsOn\n should be a boolean indicating whether or not to\n  throw exceptions when a replacement identifier is still present after\n  inflection.\n\n\ntargetReplacementIdentifier\n specifies the character to use when identifying\n  replacement variables in the target string.\n\n\nrules\n specifies an array of inflection rules; it should consist of keys\n  that specify either values or arrays of values, consistent with \naddRules()\n.\n\n\n\n\nAs examples:\n\n\n// $options implements Traversable:\n\n// With the constructor:\n$inflector = new Zend\\Filter\\Inflector($options);\n\n// Or with setOptions():\n$inflector = new Zend\\Filter\\Inflector();\n$inflector->setOptions($options);",
            "title": "String Inflection"
        },
        {
            "location": "/inflector/#string-inflection",
            "text": "Zend\\Filter\\Inflector  is a general purpose tool for rules-based inflection of\nstrings to a given target.  As an example, you may find you need to transform MixedCase or camelCasedWords\ninto a path; for readability, OS policies, or other reasons, you also need to\nlower case this; and finally, you want to separate the words using a dash\n( - ). An inflector can do this for you.  Zend\\Filter\\Inflector  implements  Zend\\Filter\\FilterInterface ; you perform\ninflection by calling  filter()  on the object instance.",
            "title": "String Inflection"
        },
        {
            "location": "/inflector/#transforming-mixedcase-and-camelcasetext-to-another-format",
            "text": "$inflector = new Zend\\Filter\\Inflector('pages/:page.:suffix');\n$inflector->setRules([\n    ':page'  => ['Word\\CamelCaseToDash', 'StringToLower'],\n    'suffix' => 'html',\n]);\n\n$string   = 'camelCasedWords';\n$filtered = $inflector->filter(['page' => $string]);\n// pages/camel-cased-words.html\n\n$string   = 'this_is_not_camel_cased';\n$filtered = $inflector->filter(['page' => $string]);\n// pages/this_is_not_camel_cased.html",
            "title": "Transforming MixedCase and camelCaseText to another format"
        },
        {
            "location": "/inflector/#operation",
            "text": "An inflector requires a  target  and one or more  rules . A target is\nbasically a string that defines placeholders for variables you wish to\nsubstitute. These are specified by prefixing with a  : :  :script .  When calling  filter() , you then pass in an array of key and value pairs\ncorresponding to the variables in the target.  Each variable in the target can have zero or more rules associated with them.\nRules may be either  static  or refer to a zend-filter class. Static rules\nwill replace with the text provided.  Otherwise, a class matching the rule\nprovided will be used to inflect the text. Classes are typically specified\nusing a short name indicating the filter name stripped of any common prefix.  As an example, you can use any zend-filter concrete implementations; however,\ninstead of referring to them as  Zend\\I18n\\Filter\\Alpha  or Zend\\Filter\\StringToLower , you'd specify only  Alpha  or  StringToLower .",
            "title": "Operation"
        },
        {
            "location": "/inflector/#using-custom-filters",
            "text": "Zend\\Filter\\Inflector  uses  Zend\\Filter\\FilterPluginManager  to manage\nloading filters to use with inflection. By default, filters registered with Zend\\Filter\\FilterPluginManager  are available. To access filters with that\nprefix but which occur deeper in the hierarchy, such as the various  Word \nfilters, simply strip off the  Zend\\Filter  prefix:  // use Zend\\Filter\\Word\\CamelCaseToDash as a rule\n$inflector->addRules(['script' => 'Word\\CamelCaseToDash']);  To use custom filters, you have two choices: reference them by fully qualified\nclass name (e.g.,  My\\Custom\\Filter\\Mungify ), or manipulate the composed FilterPluginManager  instance.  $filters = $inflector->getPluginManager();\n$filters->addInvokableClass('mungify', 'My\\Custom\\Filter\\Mungify');",
            "title": "Using Custom Filters"
        },
        {
            "location": "/inflector/#setting-the-inflector-target",
            "text": "The inflector target is a string with some placeholders for variables.\nPlaceholders take the form of an identifier, a colon ( : ) by default, followed\nby a variable name:  :script ,  :path , etc. The  filter()  method looks for\nthe identifier followed by the variable name being replaced.  You can change the identifier using the  setTargetReplacementIdentifier() \nmethod, or passing it as the fourth argument to the constructor:  // Via constructor:\n$inflector = new Zend\\Filter\\Inflector('#foo/#bar.#sfx', array(), null, '#');\n\n// Via accessor:\n$inflector->setTargetReplacementIdentifier('#');  Typically, you will set the target via the constructor. However, you may want\nto re-set the target later.  setTarget()  can be used for this purpose:  $inflector->setTarget('layouts/:script.phtml');  Additionally, you may wish to have a class member for your class that you can\nuse to keep the inflector target updated \u2014 without needing to directly update\nthe target each time (thus saving on method calls).  setTargetReference() \nallows you to do this:  class Foo\n{\n    /**\n     * @var string Inflector target\n     */\n    protected $target = 'foo/:bar/:baz.:suffix';\n\n    /**\n     * Constructor\n     * @return void\n     */\n    public function __construct()\n    {\n        $this->inflector = new Zend\\Filter\\Inflector();\n        $this->inflector->setTargetReference($this->target);\n    }\n\n    /**\n     * Set target; updates target in inflector\n     *\n     * @param  string $target\n     * @return Foo\n     */\n    public function setTarget($target)\n    {\n        $this->target = $target;\n        return $this;\n    }\n}",
            "title": "Setting the Inflector Target"
        },
        {
            "location": "/inflector/#inflection-rules",
            "text": "As mentioned in the introduction, there are two types of rules: static and filter-based.",
            "title": "Inflection Rules"
        },
        {
            "location": "/inflector/#order-is-important",
            "text": "It is important to note that regardless of the method in which you add rules\nto the inflector, either one-by-one, or all-at-once; the order is very\nimportant. More specific names, or names that might contain other rule names,\nmust be added before least specific names. For example, assuming the two rule\nnames  moduleDir  and  module , the  moduleDir  rule should appear before\nmodule since  module  is contained within  moduleDir . If  module  were added\nbefore  moduleDir ,  module  will match part of  moduleDir  and process it\nleaving  Dir  inside of the target uninflected.",
            "title": "Order is important"
        },
        {
            "location": "/inflector/#static-rules",
            "text": "Static rules do simple string substitution; use them when you have a segment in\nthe target that will typically be static, but which you want to allow the\ndeveloper to modify. Use the  setStaticRule()  method to set or modify the\nrule:  $inflector = new Zend\\Filter\\Inflector(':script.:suffix');\n$inflector->setStaticRule('suffix', 'phtml');\n\n// change it later:\n$inflector->setStaticRule('suffix', 'php');  Much like the target itself, you can also bind a static rule to a reference,\nallowing you to update a single variable instead of require a method call; this\nis often useful when your class uses an inflector internally, and you don't\nwant your users to need to fetch the inflector in order to update it. The setStaticRuleReference()  method is used to accomplish this:  class Foo\n{\n    /**\n     * @var string Suffix\n     */\n    private $suffix = 'phtml';\n\n    /**\n     * Constructor\n     * @return void\n     */\n    public function construct()\n    {\n        $this->inflector = new Zend\\Filter\\Inflector(':script.:suffix');\n        $this->inflector->setStaticRuleReference('suffix', $this->suffix);\n    }\n\n    /**\n     * Set suffix; updates suffix static rule in inflector\n     *\n     * @param  string $suffix\n     * @return Foo\n     */\n    public function setSuffix($suffix)\n    {\n        $this->suffix = $suffix;\n        return $this;\n    }\n}",
            "title": "Static Rules"
        },
        {
            "location": "/inflector/#filter-based-inflector-rules",
            "text": "Zend\\Filter  filters may be used as inflector rules as well. Just like static\nrules, these are bound to a target variable; unlike static rules, you may\ndefine multiple filters to use when inflecting. These filters are processed in\norder, so be careful to register them in an order that makes sense for the data\nyou receive.  Rules may be added using  setFilterRule()  (which overwrites any previous rules\nfor that variable) or  addFilterRule()  (which appends the new rule to any\nexisting rule for that variable). Filters are specified in one of the following\nways:   String . The string may be a filter class name, or a class name segment\n  minus any prefix set in the inflector's plugin loader (by default, minus the\n  ' Zend\\Filter ' prefix).  Filter object . Any object instance implementing\n   Zend\\Filter\\FilterInterface  may be passed as a filter.  Array . An array of one or more strings or filter objects as defined above.   $inflector = new Zend\\Filter\\Inflector(':script.:suffix');\n\n// Set rule to use Zend\\Filter\\Word\\CamelCaseToDash filter\n$inflector->setFilterRule('script', 'Word\\CamelCaseToDash');\n\n// Add rule to lowercase string\n$inflector->addFilterRule('script', new Zend\\Filter\\StringToLower());\n\n// Set rules en-masse\n$inflector->setFilterRule('script', [\n    'Word\\CamelCaseToDash',\n    new Zend\\Filter\\StringToLower()\n]);",
            "title": "Filter-Based Inflector Rules"
        },
        {
            "location": "/inflector/#setting-many-rules-at-once",
            "text": "Typically, it's easier to set many rules at once than to configure a single\nvariable and its inflection rules one at a time.  Zend\\Filter\\Inflector 's addRules()  and  setRules()  methods allow this.  Each method takes an array of variable and rule pairs, where the rule may be\nwhatever the type of rule accepts (string, filter object, or array). Variable\nnames accept a special notation to allow setting static rules and filter rules,\naccording to the following notation:   :  prefix : filter rules.  No prefix : static rule.   As an example:  // Could also use setRules() with this notation:\n$inflector->addRules([\n    // Filter rules:\n    ':controller' => ['Word\\CamelCaseToUnderscore','StringToLower'],\n    ':action'     => ['Word\\CamelCaseToUnderscore','StringToLower'],\n\n    // Static rule:\n    'suffix'      => 'phtml',\n]);",
            "title": "Setting Many Rules At Once"
        },
        {
            "location": "/inflector/#utility-methods",
            "text": "Zend\\Filter\\Inflector  has a number of utility methods for retrieving and\nsetting the plugin loader, manipulating and retrieving rules, and controlling\nif and when exceptions are thrown.   setPluginManager()  can be used when you have configured your own\n   Zend\\Filter\\FilterPluginManager  instance and wish to use it with\n   Zend\\Filter\\Inflector ;  getPluginManager()  retrieves the currently set\n  one.  setThrowTargetExceptionsOn()  can be used to control whether or not\n   filter()  throws an exception when a given replacement identifier passed to\n  it is not found in the target. By default, no exceptions are thrown.\n   isThrowTargetExceptionsOn()  will tell you what the current value is.  getRules($spec = null)  can be used to retrieve all registered rules for all\n  variables, or just the rules for a single variable.  getRule($spec, $index)  fetches a single rule for a given variable; this can\n  be useful for fetching a specific filter rule for a variable that has a\n  filter chain.  $index  must be passed.  clearRules()  will clear all currently registered rules.",
            "title": "Utility Methods"
        },
        {
            "location": "/inflector/#using-a-traversable-or-an-array",
            "text": "You can use a  Traversable  or an array to set rules and other object state in\nyour inflectors, by passing either type to either the constructor or the setOptions()  method. The following settings may be specified:   target  specifies the inflection target.  pluginManager  specifies the  Zend\\Filter\\FilterPluginManager  instance or\n  extension to use for obtaining plugins; alternately, you may specify a class\n  name of a class that extends the  FilterPluginManager .  throwTargetExceptionsOn  should be a boolean indicating whether or not to\n  throw exceptions when a replacement identifier is still present after\n  inflection.  targetReplacementIdentifier  specifies the character to use when identifying\n  replacement variables in the target string.  rules  specifies an array of inflection rules; it should consist of keys\n  that specify either values or arrays of values, consistent with  addRules() .   As examples:  // $options implements Traversable:\n\n// With the constructor:\n$inflector = new Zend\\Filter\\Inflector($options);\n\n// Or with setOptions():\n$inflector = new Zend\\Filter\\Inflector();\n$inflector->setOptions($options);",
            "title": "Using a Traversable or an array"
        },
        {
            "location": "/static-filter/",
            "text": "Using the StaticFilter\n\n\nIf it is inconvenient to load a given filter class and create an instance of\nthe filter, you can use \nStaticFilter\n with it's method \nexecute()\n as an\nalternative invocation style. The first argument of this method is a data input\nvalue that you would pass to the \nfilter()\n method. The second argument is a\nstring, which corresponds to the basename of the filter class, relative to the\n\nZend\\Filter\n namespace. The \nexecute()\n method automatically loads the class,\ncreates an instance, and applies the \nfilter()\n method to the data input.\n\n\necho StaticFilter::execute('&', 'HtmlEntities');\n\n\n\nYou can also pass an array of constructor arguments, if they are needed for the filter class:\n\n\necho StaticFilter::execute(\n    '\"',\n    'HtmlEntities',\n    ['quotestyle' => ENT_QUOTES]\n);\n\n\n\nThe static usage can be convenient for invoking a filter ad hoc, but if you\nhave the need to run a filter for multiple inputs, it's more efficient to\ncreate an instance of the filter and invoke it.  instance of the filter object\nand calling its \nfilter()\n method.\n\n\nAdditionally, \nfilter chains\n allow you to instantiate and run multiple filters\non demand to process sets of input data.\n\n\nUsing custom filters\n\n\nYou can set and receive the \nFilterPluginManager\n for the \nStaticFilter\n to\namend the standard filter classes:\n\n\n$pluginManager = StaticFilter::getPluginManager()\n    ->setInvokableClass('myNewFilter', 'MyCustom\\Filter\\MyNewFilter');\n\nStaticFilter::setPluginManager(new MyFilterPluginManager());\n\n\n\nThis is useful when adding custom filters to be used by the \nStaticFilter\n.",
            "title": "Static Filter"
        },
        {
            "location": "/static-filter/#using-the-staticfilter",
            "text": "If it is inconvenient to load a given filter class and create an instance of\nthe filter, you can use  StaticFilter  with it's method  execute()  as an\nalternative invocation style. The first argument of this method is a data input\nvalue that you would pass to the  filter()  method. The second argument is a\nstring, which corresponds to the basename of the filter class, relative to the Zend\\Filter  namespace. The  execute()  method automatically loads the class,\ncreates an instance, and applies the  filter()  method to the data input.  echo StaticFilter::execute('&', 'HtmlEntities');  You can also pass an array of constructor arguments, if they are needed for the filter class:  echo StaticFilter::execute(\n    '\"',\n    'HtmlEntities',\n    ['quotestyle' => ENT_QUOTES]\n);  The static usage can be convenient for invoking a filter ad hoc, but if you\nhave the need to run a filter for multiple inputs, it's more efficient to\ncreate an instance of the filter and invoke it.  instance of the filter object\nand calling its  filter()  method.  Additionally,  filter chains  allow you to instantiate and run multiple filters\non demand to process sets of input data.",
            "title": "Using the StaticFilter"
        },
        {
            "location": "/static-filter/#using-custom-filters",
            "text": "You can set and receive the  FilterPluginManager  for the  StaticFilter  to\namend the standard filter classes:  $pluginManager = StaticFilter::getPluginManager()\n    ->setInvokableClass('myNewFilter', 'MyCustom\\Filter\\MyNewFilter');\n\nStaticFilter::setPluginManager(new MyFilterPluginManager());  This is useful when adding custom filters to be used by the  StaticFilter .",
            "title": "Using custom filters"
        },
        {
            "location": "/writing-filters/",
            "text": "Writing Filters\n\n\nZend\\Filter\n supplies a set of commonly needed filters, but developers will\noften need to write custom filters for their particular use cases. You can do\nso by writing classes that implement \nZend\\Filter\\FilterInterface\n, which\ndefines a single method, \nfilter()\n.\n\n\nExample\n\n\nnamespace Application\\Filter;\n\nuse Zend\\Filter\\FilterInterface;\n\nclass MyFilter implements FilterInterface\n{\n    public function filter($value)\n    {\n        // perform some transformation upon $value to arrive on $valueFiltered\n\n        return $valueFiltered;\n    }\n}\n\n\n\nTo attach an instance of the filter defined above to a filter chain:\n\n\n$filterChain = new Zend\\Filter\\FilterChain();\n$filterChain->attach(new Application\\Filter\\MyFilter());\n\n\n\nAlternately, add it to the \nFilterPluginManager\n:\n\n\n$filterChain = new Zend\\Filter\\FilterChain();\n$filterChain\n    ->getPluginManager()\n    ->setInvokableClass('myfilter', Application\\Filter\\MyFilter::class)\n$filterChain->attachByName('myfilter');",
            "title": "Writing Filters"
        },
        {
            "location": "/writing-filters/#writing-filters",
            "text": "Zend\\Filter  supplies a set of commonly needed filters, but developers will\noften need to write custom filters for their particular use cases. You can do\nso by writing classes that implement  Zend\\Filter\\FilterInterface , which\ndefines a single method,  filter() .",
            "title": "Writing Filters"
        },
        {
            "location": "/writing-filters/#example",
            "text": "namespace Application\\Filter;\n\nuse Zend\\Filter\\FilterInterface;\n\nclass MyFilter implements FilterInterface\n{\n    public function filter($value)\n    {\n        // perform some transformation upon $value to arrive on $valueFiltered\n\n        return $valueFiltered;\n    }\n}  To attach an instance of the filter defined above to a filter chain:  $filterChain = new Zend\\Filter\\FilterChain();\n$filterChain->attach(new Application\\Filter\\MyFilter());  Alternately, add it to the  FilterPluginManager :  $filterChain = new Zend\\Filter\\FilterChain();\n$filterChain\n    ->getPluginManager()\n    ->setInvokableClass('myfilter', Application\\Filter\\MyFilter::class)\n$filterChain->attachByName('myfilter');",
            "title": "Example"
        }
    ]
}